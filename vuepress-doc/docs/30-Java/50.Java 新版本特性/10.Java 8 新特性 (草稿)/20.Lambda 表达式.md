---
title: Lambda 表达式
date: 2022-10-05 18:04:10
permalink: /pages/a9bf03/
---


Lambda 表达式，也可称为**闭包**，它是推动 Java 8 发布的最重要新特性。

**Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）**。

使用 Lambda 表达式可以使代码变的更加简洁紧凑。

## 基本语法

> 参考 [菜鸟教程](https://www.runoob.com/java/java8-new-features.html)

lambda 表达式的语法格式如下：

```java
(parameters) -> expression 
// 或 
(parameters) ->{ statements; }
```

以下是 lambda 表达式的重要特征:

- **可选类型声明：**<u>不需要声明参数类型，编译器可以统一识别参数值</u>。
- **可选的参数圆括号：**<u>一个参数无需定义圆括号，但多个参数需要定义圆括号</u>。
- **可选的大括号：**<u>如果主体包含了一个语句，就不需要使用大括号</u>。
- **可选的返回关键字：**<u>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值</u>。

Lambda 表达式的简单例子:

```java
// 1. 不需要参数,返回值为 5  
() -> 5  
  
// 2. 接收一个参数(数字类型),返回其2倍的值  
x -> 2 * x  
  
// 3. 接受 2 个参数(数字),并返回他们的差值  
(x, y) -> x – y
// 或者
(x, y) -> {
	return x - y;
}
  
// 4. 接收2个int型整数,返回他们的和  
(int x, int y) -> x + y  
  
// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
(String s) -> System.out.print(s)
```

## 函数式接口

> 参考 https://juejin.cn/post/7121508320493453326#heading-2

Lambda表达式需要 “函数式接口” 的支持

在 Java 中，所有的函数式接口都是以 `@Functionallnterface` 进行标注的，就像这样：

```java
// 函数式接口
@Functionallnterface
public interface GreetingService {
	public abstract void sayMessage(String message);
}
```

在一个接口上打上 `@Functionallnterface` 并且定义一个抽象方法，这样的类我们就称之为函数式接口，当然这个方法并不一定非要用抽象关键字来修饰，比如：

```java
// 函数式接口
@Functionallnterface
public interface GreetingService {
	public void sayMessage(String message);
}
```

更甚至，**不写 `@Functionallnterface` 注解也没关系，只需要保证，这个接口只定义了一个抽象方法**（接口的默认方法不算，那个可以称得上是接口的静态方法了）

```java
// 函数式接口
public interface GreetingService {
	public void sayMessage(String message);
}
```

为什么只能有一个抽象方法呢？因为你的自定义逻辑就是这个方法的匿名函数，最终会调用这个方法，所以只能有一个。

然后你就可以使用 Lambda 表达式来进行书写了，就像这样：

```java
public static void main(String args[]){
//        GreetingService greetService1 = new GreetingService() {
//            @Override
//            public void sayMessage(String message) {
//                System.out.println(message);
//            }
//        };
    GreetingService greetService1 = message -> System.out.println(message);
    greetService1.sayMessage("Hello"); // Hello
}
```

看吧，很方便的写法就定义了一个 GreetingService 的匿名子类出来，不过使用 Lambda 只是为了生成一个匿名子类的情况确实无法完全发挥Lambda 的作用，**Lambda 更大的作用还是在解决具体的问题上（结合 Stream 流来用，下文会解释），而非创造一个匿名类**。

## 四大函数式接口

> 来自 https://juejin.cn/post/7121508320493453326

JDK 一共提供了四个对具体场景进行顶级抽象的函数式接口，：

1. `Consumer`
2. `Supplier`
3. `Predicate`
4. `Function`

除了这四个之外还有大量的衍生函数式接口（主要在 `java.util.function` 包下），在 JDK8 中就有 50 个左右，不过都是在这四个基础上进行修改，不必担心记不住的问题。

比如函数式接口 Comparator 和 Function 就差不多：

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

### Consumer

**Consumer **通过名字可以看出它是一个消费函数式接口，主要针对的是`消费`这个场景，它的代码定义如下：

```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
```

通过泛型 T 定义了一个入参，但是没有返回值，它代表你可以针对这个入参做一些自定义逻辑，比较典型的例子是 Stream 中的 **forEach** 方法。

而我们的主要使用场景也往往是循环进行某项操作，比如有一堆手机号，循环进行发短信。

> `Iterable` 接口提供的默认方法 forEach 传入的参数就是函数式接口 Consumer：
>
> ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221005162757982.png)
>
> 举个例子：
>
> ```java
> List<Integer> list = Arrays.asList(1, 2, 3);
> list.forEach(i -> System.out.println(i + 1)); // 输出 2 3 4
> ```

所以消费场景是 **Consumer** 的主要用武之地，但是有时候你还面临一个问题，一个入参似乎太少了，有时候你需要对两个对象进行操作，又懒得将它们合并成一个对象，这种情况 JDK 提供了 **BiConsumer**：

```java
@FunctionalInterface
public interface BiConsumer<T, U> {

    void accept(T t, U u);
}
```

这种你可以直接传进去两个参数了，什么？你想要三个参数的？那没有，三个或者三个以上我感觉就有必要合并成一个对象进行消费了。

除了这两个之外，还有**DoubleConsumer**、**IntConsumer**和**LongConsumer**这种限定了入参类型的 **Consumer**，这里不再多述。

### Supplier

**Supplier**通过名字比较难看出来它是一个场景的函数式接口，它主要针对的是`get`这个场景或者说`获取`这个场景，它的代码定义如下：

```java
@FunctionalInterface
public interface Supplier<T> {

    T get();
}
```

通过泛型 T 定义了一个返回值类型，但是没有入参，它代表你可以针对调用方获取某个值，比较典型的例子是 Stream 中的 **collect** 方法，通过自定义传入我们想要取得的某种对象进行对象收集。

而我们的主要使用场景也往往是收集和聚合这个场景了，这个场景我们也是对**获得**这个场景进行收集。

和Consumer一样，**Supplier**还具有以下衍生接口：

1. **BooleanSupplier**
2. **DoubleSupplier**
3. **IntSupplier**
4. **LongSupplier**

都是提前对获取的定义好了数据类型，思想一致，这里不再多述。

### Predicate

**Predicate**前文我们已经介绍过，它主要针对的是`判断`这个场景，它的代码定义如下：

```java
@FunctionalInterface
public interface Predicate<T> {

    boolean test(T t);
}
```

通过泛型 T 定义了一个入参，返回了一个布尔值，它代表你可以传入一段判断逻辑的函数，比较典型的例子是 Stream 中的 **filter**方法。

我们对于它的使用场景实在是太多了，基本上做任何业务都有在内存中进行筛选 or 判断的场景。

所以判断和筛选场景是 **Predicate**的主要用武之地，但是有时候你还面临和上面一样的问题，一个入参似乎太少了，有时候你需要对两个对象进行操作，又懒得将它们合并成一个对象，这种情况 JDK 提供了 **BiPredicate**：

```java
@FunctionalInterface
public interface BiPredicate<T, U> {

    boolean test(T t, U u);
}
```

这种你可以直接传进去两个参数进行函数的自定义逻辑。

除了这两个之外，还有**DoublePredicate**、**IntPredicate**和**LongPredicate**这种限定了入参类型的**Predicate**，这里不再多述。

### Function

**Function** 接口的名字不太能轻易看出来它的场景，它主要针对的则是 `转换`这个场景，其实说转换可能也不太正确，它是一个覆盖范围比较广的场景，你也可以理解为扩展版的Consumer，接口定义如下：

```java
@FunctionalInterface
public interface Function<T, R> {
	R apply(T t);
}
```

**通过一个入参 T 进行自定义逻辑处理，最终得到一个出参 R**，比较典型的例子是 Stream 中的 **map** 系列方法和 **reduce** 系列方法。

为什么我说也可以理解为一个扩展版的Consumer呢？我们还举例手机号发短信的场景好了，你通过循环发完短信之后可能想拿到发完短信之后的结果对象，来进行后续处理。

这个时候单纯的Consumer就不行了，因为它没有返回值，你就可以通过 **Function** 这种函数式对象进行处理了。

和 Consumer 一样，**Function** 也有一个衍生接口可以通过两个入参返回一个对象——**BiFunction<T,U,R>**。

还有一些定义好了入参和出参的 **Function** 我这里就不再赘述了~