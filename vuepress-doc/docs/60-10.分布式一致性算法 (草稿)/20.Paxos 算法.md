---
title: Paxos 算法
date: 2022-10-08 10:30:14
permalink: /pages/4c9117/
---
> 参考：
>
> - [分布式系列文章——Paxos 算法原理与推导（图文完整版）](https://mp.weixin.qq.com/s?__biz=MzI0NDI0MTgyOA==&mid=2652037784&idx=1&sn=d8c4f31a9cfb49ee91d05bb374e5cdd5&chksm=f2868653c5f10f45fc4a64d15a5f4163c3e66c00ed2ad334fa93edb46671f42db6752001f6c0#rd)

## 什么是 Paxos

Paxos 算法是基于**消息传递**且具有**高度容错特性**的**一致性算法**，是目前公认的解决**分布式一致性**问题**最有效**的算法之一。

> 💡 早在1900年就诞生了著名的 **Paxos 经典算法** （**Zookeeper就采用了Paxos算法的近亲兄弟Zab算法**），但由于Paxos算法非常难以理解、实现、排错。所以不断有人尝试简化这一算法，直到2013年才有了重大突破：斯坦福的Diego Ongaro、John Ousterhout以易懂性为目标设计了新的一致性算法—— **Raft 算法** ，并发布了对应的论文《In Search of an Understandable Consensus Algorithm》，到现在有十多种语言实现的 Raft 算法框架，较为出名的有以Go语言实现的Etcd，它的功能类似于Zookeeper，但采用了更为主流的Rest接口。

## 问题产生的背景

在常见的分布式系统中，总会发生诸如**机器宕机**或**网络异常**（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。<u>Paxos 算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对**某个数据的值**达成**一致**，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</u>

注：这里**某个数据的值**并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）。。。根据应用场景不同，**某个数据的值**有不同的含义。

## 相关概念

在Paxos算法中，有三种角色：

- **提议者 Proposer**：提议一个值
- **接受者 Acceptor**：对每个提议进行投票
- **告知者 Learners**：被告知投票的结果，不参与投票过程

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20201122203634.png)

在具体的实现中，一个进程可能**同时充当多种角色**。比如一个进程可能**既是Proposer又是Acceptor又是Learner**。

那么，Proposer、Acceptor、Learner分别在什么情况下才能认为某个提议被选定呢？

- Proposer：只要 Proposer 发的提案被半数以上的 Acceptor 接受，Proposer 就认为该提议被选定了。
- Acceptor：只要 Acceptor 接受了某个提案，Acceptor 就认为该提议被选定了。
- Learner：Acceptor 告诉 Learner 哪个提议被选定，Learner 就认为哪个提议被选定。

## 执行过程

规定一个提议包含两个字段：`[n, v]`，其中 `n` 为序号（具有唯一性），`v` 为提议值。

### Prepare 阶段

下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20201122204117.png)

当 Acceptor 接收到一个 Prepare 请求，包含的提议为 `[n1, v1]`，**并且之前还未接收过 Prepare 请求**，那么发送一个 **Prepare 响应**，设置当前接收到的提议为 `[n1, v1]`，并且保证以后不会再接受序号小于 n1 的提议。

如下图，Acceptor X 在收到 `[n=2, v=8]` 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 `[no previous]` 的 Prepare 响应，设置当前接收到的提议为 `[n=2, v=8]`，**并且保证以后不会再接受序号小于 2 的提议**。其它的 Acceptor 类似。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20201122204220.png)

如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 `[n2, v2]`，**并且之前已经接收过提议** `[n1, v1]`：

- 如果 n1 > n2，那么就丢弃该提议请求；
- 否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 `[n1, v1]`，设置当前接收到的提议为 `[n2, v2]`，并且保证以后不会再接受序号小于 n2 的提议。

如下图，Acceptor Z 收到 Proposer A 发来的 `[n=2, v=8]` 的 Prepare 请求，由于之前已经接收过 `[n=4, v=5]` 的提议，并且 n > 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 `[n=4, v=5]` 的 Prepare 请求，因为之前接收到的提议为 `[n=2, v=8]`，并且 2 <= 4，因此就发送 `[n=2, v=8]` 的 Prepare 响应，设置当前接收到的提议为 `[n=4, v=5]`，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20201122204435.png)

### Accept 阶段

当一个 Proposer 接收到**超过一半 Acceptor 的 Prepare 响应**时，就可以发送 Accept 请求。

Proposer A 接收到两个 Prepare 响应之后，就发送 `[n=2, v=8]` Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。

Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，**Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值**，也就是 8。因此它发送 `[n=4, v=8]` 的 Accept 请求。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20201122204558.png)

### Learn 阶段

Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。

## 约束条件

- **正确性**：指只有一个提议值会生效。

  因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。

- **可终止性**：指最后总会有一个提议生效

  Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。