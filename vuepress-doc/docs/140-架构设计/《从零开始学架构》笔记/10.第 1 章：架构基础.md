## 架构设计的目的

架构设计的真正目的：**为了解决复杂度带来的问题**

架构设计并不是要面面俱到，不需要每个架构都具备高性能、高可用、高扩展等特点，而是要识别出复杂点，然后有针对性地解决问题，**不要贪大求全**！

> 比如一个内部项目，其实基本就可以不用考虑高性能
>
> 再比如你把项目的 TPS 做到 10w，但是系统的复杂度不在这块，那么做到 10w 并没有什么用

淘宝的架构是为了解决淘宝业务的复杂度而设计的，绝大多数业务的用户量都没有这么大

## 复杂度来源

### 高性能带来的复杂度

主要体现在两方面：

1）**单台计算机内部为了高性能带来的复杂度**：计算机内部复杂度最关键的地方就是 “操作系统”，和性能最相关的就是 “进程” 和 “线程”。需要考虑的技术点有 “多进程”、“多线程”、“多线程并发”、“进程间通信” 等，需要根据业务来进行选择和组合。举个例子，Nginx 使用多进程也可以用多线程，JBoss 采用多线程，Redis 采用单进程，Memcache 采用多线程

2）**多台计算机集群为了高性能带来的复杂度**：通过大量机器来提升性能，让多台机器配合起来是一个复杂的任务，关键点主要是任务分配和任务分解：

- 任务分配：不同的任务分配到不同的机器

  需要一个任务分配器，可以是硬件网络设备（F5、交换机等），也可以是软件网络设备（LVS 等），也可以是负载均衡软件（Nginx、HAProxy 等）

  ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019173720760.png)

  但随着任务复杂度的增加，任务分配器本身成为了瓶颈，也需要扩张为多台机器

  ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019173604460.png)

- 任务分解：一个大任务拆分成若干个小任务

  简单的系统更容易做到高性能，且可以方便地多单个任务进行扩展

  ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019173749944.png)

  但并不能过度拆分，如果系统拆分地太细，那为了完成某个业务，系统间的调用（通过网络传输）次数就越多，性能就越低

### 高可用带来的复杂度

“高可用” 指 “系统**无中断**地执行其功能的能力”

无论单个硬件还是单个软件，都不可能做到 100% 无中断

- 硬件会出故障、会逐渐老化
- 软件会有 bug、会越来越复杂

除此之外，外部环境比如断电、水灾等导致的不可用更是无法避免

所以，**所有宣称是保证系统高可用的方案，其实本质都是通过 “冗余” 来实现高可用**

通过 “冗余” 增强了可用性，可增加了复杂性

#### 计算高可用

这里的计算指的是计算密集型的任务

计算有个特点，就是无论在哪台机器上进行计算，同样的输入和算法一定能够得到同样的输出。

所以想要保证计算高可用，其实和我们在高性能章节说的任务分配没什么区别

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019182546801.png)

#### 存储高可用

将数据从一台机器搬到另一台机器，需要进行网络传输，那么两台机器之间就一定存在数据同步延迟

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019182803748.png)

所以存储高可用的难点不在于如何备份数据，而在于如何减少或规避数据不一致对业务造成的影响

> 需要保证存储高可用的系统，不可能同时满足 CAP（一致性、可用性、分区容错性）

#### 高可用决策

无论计算高可用还是存储高可用，其基础都是 “状态决策”，即<u>系统需要能够判断当前的决策是正常的还是出现了异常，如果出现了异常就要采取行动来保证高可用</u>

如果状态决策本身都出现了问题，那后续的任何操作也都没有意义了。

有如下几种常见的决策方式：

- 独裁式：只有一个决策者，不会出现决策混乱，但若决策者出现故障则整个系统都无法正确决策

  ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019183555539.png)

- 协商式：两个独立的个体通过交流信息，根据规则进行决策

  ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019183814281.png)

- 民主式：多个独立的个体通过投票的方式进行状态决策，比如 Redis 的选举领头 Sentinel 以及集群选主、Zookeeper 集群选主就是采用的这种方式

  ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019183959949.png)

  为了避免 ”脑裂“ 问题，民主式决策一般采用 ”获票数 > 总票数的一半“ 的规则，这种方式虽然解决了脑裂问题，但也同时了降低了整个系统的可用性（毕竟如果系统不是因为脑裂问题而是真的发生了节点宕机，导致的投票节点数过少，那么此时系统也就不会选出主节点，于是系统就宕机了）

### 可扩展性带来的复杂度

1）预测变化：提前预测场景，做好相应的架构

2）应对变化：主要有两种方案：

- **剥离变化层和稳定层、并设计变化层和稳定层之间的接口**

  ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019184958336.png)

  比如系统支持 XML\JSON\ProtocolBuffer 三种接入方式：

  ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019185028316.png)

  又比如系统底层支持三种数据库 MySQO/Oracle/DB2 存储

  ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019185051705.png)

- **提炼出”抽象层“和”实现层“，抽象层是稳定的，实现层可以根据需要进行开发**（很容易就想到了装饰者模式）

  ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019185312887.png)

### 低成本带来的复杂度

### 安全带来的复杂度

从技术的角度来说，安全可以分成两类：

- **功能上的安全**：更多的是和具体编码有关，比如 XSS 攻击、CSRF 攻击、SQL 注入等

- **架构上的安全**：比如 DDOS 攻击，直接用肉鸡占满你的服务器带宽从而让服务不可用

  传统的架构安全主要靠防火墙，通过将网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同信任程度区域间传送的数据流

  ![一个典型的银行系统的安全架构](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019185847419.png)

  防火墙性能一般且价格太贵，互联网领域由于用户基数太大，导致防火墙性能无法支持，所以互联网领域基本很少使用防火墙。

  目前没有一个很好的互联网系统的安全架构，更多的是靠运营商和云服务商强大的带宽和流量清洗的能力，较少自己来设计实现

### 规模带来的复杂度

- 功能越来越多
- 数据越来越多，比如需要考虑将单库单表拆分成多库多表（一般单表数据推荐最多在 5000 万行左右）