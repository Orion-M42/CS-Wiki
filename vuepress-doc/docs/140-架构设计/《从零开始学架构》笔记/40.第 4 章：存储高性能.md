---
title: 第 4 章：存储高性能
date: 2022-10-20 15:25:32
permalink: /pages/68805c/
---
## 关系数据库 SQL

海量用户 + 海量数据，单个数据库服务器已经很难满足业务需要，必须考虑使用数据库集群的方式来提升性能

高性能数据库集群的两种方式：

- 读写分离：并未分散存储压力，分散了访问压力
- 分库分表：既可以分散存储压力，又可以分散访问压力

### 读写分离

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221020153211327.png)

实现方式：

1. 数据库搭建主从集群
2. 主机负责写，从机负责读
3. 主机将数据复制给从机，每台服务器都存储了所有的数据！
4. 业务将写操作发给主机，都操作发给从机

**读写分离需要应对的就是主从之间数据同步延迟带来的问题**。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221020153432317.png)

常见解决方案：

1. 写操作后的读操作指定发给主机：对业务代码侵入较大，容易出 bug

2. 读从机失败后再读一次主机（二次读取）：代码侵入较小，但如果二次读取较多（比如黑客暴力破解账号），主机很可能由于访问压力太大而崩溃

3. **关键业务读写操作全部指向主机，非关键业务采取读写分离**

   ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221020153718350.png)

### 分库分表

单个数据库服务器上存的数据不能太多，否则存在如下安全隐患：

1. 数据量太大导致读写性能下降
2. 数据文件太大，导致数据库备份和恢复需要较长时间
3. 数据文件越大，极端情况下数据丢失的风险越高

常见的分散存储主要有两种方法：

- 分库
- 分表

#### 业务分库

按照**业务模块**将数据分散到不同的数据库服务器

例如电商网站，包括用户、商品、订单三个模块，将这三大模块的数据分散到三个服务器，而不是一台服务器

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221021090450574.png)

业务分库带来的问题：

1. **join 操作问题**：join 操作没法跨库。所以要想做跨库表之间的连接，只能先查一个表然后根据查出来的数据去另一个表查
2. **事务问题**：同一个数据库中的表都可以在同一个事务中进行修改，满足 ACID 特性，但是分库之后就没法使用数据库事务了，需要引入分布式事务
3. **成本问题**：本来一台服务器现在需要三台了

So，**初创业务并不建议上来就做分库分表**。后期流量大了再做也不迟

另外，**单台数据库服务器的性能其实也没那么差，一般可以支持 `10w` 用户量级的业务**

#### 分表

分库之后一般可以支撑百万甚至千万级用户规模的业务，但如果业务继续发展，同意业务的单表数据可能也会达到单台数据库服务器的处理瓶颈。

比如淘宝的用户数据几个亿，存在一张表里肯定是无法满足性能需求了

单表数据的拆分方式主要两种：

- **垂直拆分**：拆分出来的表拥有不同的列，但记录数相同

  > 垂直分表一般是把表中不常用且占了大量空间的列拆分出去，比如用户表中有 age、sex、nickname 和 description 字段，用户都是根据 age 和 sex 进行筛选查询的，那么就可以把 nickname 和 description 拆分出去

- **水平拆分**：拆分出来的表拥有相同的列，但记录数不同

  > 水平拆分适合行数特别大的表，一般表的数据达到千万级就需要考虑进行分表了

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221021092739213.png)

当然，并不局限拆分的次数

单表进行切分后，并不强制要求将切分后的表分散到不同的数据库服务器中，根据实际切分效果来定（单表切分多表后，即使都在同一个数据库服务器中，也能带来很可观的性能提升了。如果不需要分库，那就不分库，毕竟分库会带来复杂度提升）。

---

垂直分表带来的问题：

1. 垂直分表引入的复杂度主要在于原来只需要一次查询，分表后可能需要多次查询

水平分表带来的问题：

1. 路由：需要通过路由算法来确定哪条数据属于哪张表。常见的路由算法：

   - 范围路由
   - Hash 路由
   - 配置路由（用一张独立的表来记录路由信息）

2. join 操作：数据分散在多个表中，需要进行多次 join

3. count() 操作：需要进行多次 count

   > 也可以新建一张专门用来记录 count 数量的表，每插入一条记录就更新一次这张表。
   >
   > 这会提升读取 count 数量的性能，但也会提高写压力，以及出现不一致问题

4. order by 操作：没法直接 order by，需要手动获取所有分表数据，然后在业务代码中做排序

### 实现方式

读写分离和分库分表本质上都是一种**分配方式**，即将不同的 SQL 语句发送到不同的数据库服务器

常见的分配方式有两种：

1. **程序代码封装**：在代码中抽象一个数据访问层来实现读写分离和分库分表。目前成熟的开源方案 -> 淘宝的 `TDDL`（Taobao Distributed Data Layer，外号，头都大了）

   ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221021094613434.png)

   实现简单但无法复用。

2. **中间件封装**：独立一套系统出来，实现分库分表和读写分离。目前成熟的数据库中间件有比如 MySQL 官方推的 `MySQL Router`、奇虎 360 的 `Atlas` 等

   ![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221021094857188.png)

## 非关系数据库 NoSQL

NoSQL != No SQL, NoSQL = Not Only SQL

NoSQL 是对 SQL 的强力补充，但本质上是会牺牲 ACID 中的某个或某几个特性来完成的

常见的 NoSQL 方案：

1. KV 存储：Redis
2. 文档数据库：MongoDB
3. 列式数据库：HBase
4. 全文搜索引擎：ElasticSearch

## 缓存 Cache

- 缓存穿透

- 缓存雪崩

- 缓存击穿

- 缓存热点：由于单个数据过于热点，导致这份缓存数据所在的服务器访问压力太大。

  缓存热点的解决方案就是复制多份缓存，将请求分散到多个缓存服务器上