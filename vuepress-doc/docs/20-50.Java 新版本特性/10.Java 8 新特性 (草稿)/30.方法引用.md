---
title: 方法引用
date: 2022-10-05 18:04:26
permalink: /pages/f37b66/
---


> 参考：https://juejin.cn/post/6844904184953700360

<u>方法引用啥时候使用，同样也是在 Stream 流中，Stream 的左膀右臂：方法引用 和 Lambda 表达式</u>

**方法引用的出现，使得我们可以将一个方法赋给一个变量或者作为参数传递给另外一个方法。`::`双冒号作为方法引用的符号**，比如下面这两行语句，引用 `Integer`类的 `parseInt`方法。

```java
Function<String, Integer> s = Integer::parseInt;
Integer i = s.apply("10");
```

或者下面这两行，引用 `Integer`类的 `compare`方法。

```java
Comparator<Integer> comparator = Integer::compare;
int result = comparator.compare(100,10);
```

再比如，下面这两行代码，同样是引用 `Integer`类的 `compare`方法，但是返回类型却不一样，但却都能正常执行，并正确返回。

```java
IntBinaryOperator intBinaryOperator = Integer::compare;
int result = intBinaryOperator.applyAsInt(10,100);
```

相信有的同学看到这里恐怕是下面这个状态，完全不可理喻吗，也太随便了吧，返回给谁都能接盘。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/10/1729bd28113e1081~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

先别激动，来来来，现在咱们就来解惑，解除蒙圈脸。

**Q：什么样的方法可以被引用？**

A：这么说吧，任何你有办法访问到的方法都可以被引用。

**Q：返回值到底是什么类型？**

A：这就问到点儿上了，上面又是 `Function`、又是`Comparator`、又是 `IntBinaryOperator`的，看上去好像没有规律，其实不然。

返回的类型是 Java 8 专门定义的函数式接口，这类接口用 `@FunctionalInterface` 注解。

比如 `Function`这个函数式接口的定义如下：

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
```

还有很关键的一点，你的【**引用方法的参数个数、类型，返回值类型要和函数式接口中的方法声明一一对应才行**】。

比如 `Integer.parseInt`方法定义如下：

```java
public static int parseInt(String s) throws NumberFormatException {
    return parseInt(s,10);
}
```

首先`parseInt`方法的参数个数是 1 个，而 `Function`中的 `apply`方法参数个数也是 1 个，参数个数对应上了，再来，`apply`方法的参数类型和返回类型是泛型类型，所以肯定能和 `parseInt`方法对应上。

这样一来，就可以正确的接收`Integer::parseInt`的方法引用，并可以调用`Funciton`的`apply`方法，这时候，调用到的其实就是对应的 `Integer.parseInt`方法了。

用这套标准套到 `Integer::compare`方法上，就不难理解为什么即可以用 `Comparator<Integer>`接收，又可以用 `IntBinaryOperator`接收了，而且调用它们各自的方法都能正确的返回结果。

`Integer.compare`方法定义如下：

```java
public static int compare(int x, int y) {
    return (x < y) ? -1 : ((x == y) ? 0 : 1);
}
```

返回值类型 `int`，两个参数，并且参数类型都是 `int`。

然后来看`Comparator`和`IntBinaryOperator`它们两个的函数式接口定义和其中对应的方法：

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}

@FunctionalInterface
public interface IntBinaryOperator {
    int applyAsInt(int left, int right);
}
```

对不对，都能正确的匹配上，所以前面示例中用这两个函数式接口都能正常接收。其实不止这两个，只要是在某个函数式接口中声明了这样的方法：两个参数，参数类型是 `int`或者泛型，并且返回值是 `int`或者泛型的，都可以完美接收 `Integer.compare(int x, int y)` 方法。

<br>

方法引用实例，来自 https://www.runoob.com/java/java8-method-references.html：

```java
public class Java8Tester {
   public static void main(String args[]){
      List<String> names = new ArrayList();
        
      names.add("Google");
      names.add("Runoob");
      names.add("Taobao");
      names.add("Baidu");
      names.add("Sina");
       
      // 遍历并输出 names
      names.forEach(System.out::println);
   }
}
```

