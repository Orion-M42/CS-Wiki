---
title: 分布式事务
date: 2020-11-24 10:19:50
permalink: /pages/distributed-transaction/
---
> 参考《阿里巴巴java性能调优实战.pdf》

我们讲过，在单个数据库的情况下，数据事务操作具有 ACID 四个特性，但如果在一个事 务中操作多个数据库，则无法使用数据库事务来保证一致性。 

也就是说，**当两个数据库操作数据时，可能存在一个数据库操作成功，而另一个数据库操作 失败的情况，【我们无法通过单个数据库事务来回滚两个数据操作】**。

而<u>分布式事务就是为了解决在同一个事务下，不同节点的数据库操作数据不一致的问题。**在一个事务操作请求多个服务或多个数据库节点时，要么所有请求成功，要么所有请求都失败 回滚回去**</u>。

通常，分布式事务的实现有多种方式，例如 XA 协议实现的二阶提交（2PC）、 三阶提交 (3PC)，以及 TCC 补偿性事务。

在了解 2PC 和 3PC 之前，我们有必要先来了解下【**XA 协议】**。XA 协议是由 X/Open 组织提 出的一个分布式事务处理规范，**目前 MySQL 中只有 InnoDB 存储引擎支持 XA 协议**。

### XA 协议

在 XA 规范/协议之前，存在着一个【**DTP 模型**】，该模型规范了分布式事务的模型设计。

DTP 规范中主要包含了 AP、RM、TM 三个部分

- AP 是应用程序（Application Program），是事务发起和结束的地方
- RM 是资源管理器（Resource Manager），主要负责管理每个数据库的连接数据源
- TM 是事务管理器（Transaction Manager），负责事务的全局管理，包括事务的生命周期管理和资源的分配协调等

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20220927224852434.png)

**XA 协议则规范了 TM 与 RM 之间的通信接口，在 TM 与多个 RM 之间形成一个双向通信桥 梁，从而在多个数据库资源下保证 ACID 四个特性**。

### 二阶段和三阶段提交

> 这里强调一下，Spring 中的 JTA 框架是基于 XA 规范实现的一套 Java 事务编程接口，是一种两阶段提交事务

**XA 规范实现的分布式事务属于二阶提交事务**，顾名思义就是通过两个阶段来实现事务的提交

1）**准备阶段**：在第一阶段，应用程序向事务管理器（TM）发起事务请求，而事务管理器则会分别向参与的各个资源管理器（RM）发送事务预处理请求（**Prepare**），此时<u>这些资源管理器会打开本地数据库事务，然后开始执行数据库事务，但执行完成后并不会立刻提交事务，而是向事 务管理器返回已就绪（Ready）或未就绪（Not Ready）状态</u>。如果各个参与节点都返回状 态了，就会进入第二阶段。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20220927225052270.png)

2）到了第二阶段，如果资源管理器返回的都是就绪状态，事务管理器则会向各个资源管理器发送提交（**Commit**）通知，<u>资源管理器则会完成本地数据库的事务提交，最终返回提交结果 给事务管理器</u>。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20220927225116881.png)

在第二阶段中，**如果任意资源管理器返回了未就绪状态，此时事务管理器会向【所有】资源管理器发送事务回滚（Rollback）通知，此时各个资源管理器就会回滚本地数据库事务，释放资源**，并返回结果通知。

但事实上，二阶事务提交也存在一些缺陷

- 第一，在整个流程中，我们会发现**各个资源管理器节点存在阻塞**，只有当所有的节点都准备 完成之后，事务管理器才会发出进行全局事务提交的通知，这个过程如果很长，则会有很多 节点长时间占用资源，从而影响整个节点的性能。 

  一旦资源管理器挂了，就会出现一直阻塞等待的情况。类似问题，我们可以通过设置事务超时时间来解决

- 第二，仍然**存在数据不一致的可能性**，例如，在最后通知提交全局事务时，由于网络故障， 部分节点有可能收不到通知，由于这部分节点没有提交事务，就会导致数据不一致的情况出 现。



三阶事务（3PC）的出现就是为了减少此类问题的发生。 **3PC 把 2PC 的准备阶段（第一阶段）分为了准备阶段和预处理阶段，在第一阶段只是询问各个资源节点 是否可以执行事务，而在第二阶段，所有的节点反馈可以执行事务，才开始执行事务操作**， 最后在第三阶段执行提交或回滚操作。并且在事务管理器和资源管理器中都引入了超时机制，如果在第三阶段，资源节点一直无法收到来自资源管理器的提交或回滚请求，它就会在 超时之后，继续提交事务

所以 3PC 可以通过超时机制，避免管理器挂掉所造成的长时间阻塞问题，**但其实这样还是 无法解决在最后提交全局事务时，由于网络故障无法通知到一些节点的问题，特别是回滚通知，这样会导致事务等待超时从而默认提交**。

### TCC 补偿性事务

以上这种基于 XA 规范实现的事务提交，由于阻塞等性能问题，有着比较明显的低性能、低 吞吐的特性。所以在抢购活动中使用该事务，很难满足系统的并发性能。

除了性能问题，JTA 只能解决同一服务下操作多数据源的分布式事务问题，换到微服务架构下，可能存在同一个事务操作，分别在不同服务上连接数据源，提交数据库操作。 

而 TCC 正是为了解决以上问题而出现的一种分布式事务解决方案。TCC 采用最终一致性的方式实现了一种柔性分布式事务，与 XA 规范实现的二阶事务不同的是，TCC 的实现是基于服务层实现的一种二阶事务提交

> 在跨服务的分布式事务下，我们可以考虑基于 TCC 实现的分布式事务，常用的中间件有 TCC-Transaction。TCC 也是基于二阶事务提交原理实现的，但 TCC 的二阶事务提交是提 到了服务层实现。
>
> TCC 方式虽然提高了分布式事务的整体性能，但也给业务层带来了非常大的工作量，对应用服务的侵入性非常强，但这是大多数公司目前所采用的分布式事务解决 方案。

**TCC 分为三个阶段，即 Try、Confirm、Cancel 三个阶段**

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20220927225621212.png)

- Try 阶段：主要尝试执行业务，执行每个服务中的 Try 方法，主要包括预留操作；
- Confirm 阶段：确认 Try 中的各个方法执行成功，然后通过 TM 调用各个服务的 Confirm 方法，这个阶段是提交阶段；
- Cancel 阶段：**当在 Try 阶段发现其中一个 Try 方法失败，例如预留资源失败、代码异常 等，则会触发 TM 调用各个服务的 Cancel 方法，对全局事务进行回滚，取消执行业务**。

以上执行只是保证 Try 阶段执行时成功或失败的提交和回滚操作，你肯定会想到，**如果在 Confirm 和 Cancel 阶段出现异常情况，那 TCC 该如何处理呢？此时 TCC 会不停地重试调 用失败的 Confirm 或 Cancel 方法，直到成功为止**。

首先，我们需要在业务设计的时候考虑预留资源；然后，我们需要编写大量业务性代码，例 如 Try、Confirm、Cancel 方法；最后，我们还需要为每个方法考虑幂等性。这种事务的 实现和维护成本非常高，但综合来看，这种实现是目前大家最常用的分布式事务解决方案。

### 业务无侵入方案：Seata(Fescar) TODO