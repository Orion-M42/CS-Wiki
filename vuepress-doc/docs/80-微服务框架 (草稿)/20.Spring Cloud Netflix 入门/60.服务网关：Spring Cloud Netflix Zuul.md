---
title: 服务网关：Spring Cloud Netflix Zuul
date: 2022-10-19 14:40:01
permalink: /pages/55675e/
---
## 什么是服务网关

> 参考 https://blog.didispace.com/spring-cloud-starter-dalston-6-1/

通过之前几篇Spring Cloud中几个核心组件的介绍，我们已经可以构建一个简略的（不够完善）微服务架构了。比如下图所示：

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019144535923.png)

我们使用 Spring Cloud Netflix中 的 Eureka 实现了服务注册中心以及服务注册与发现；而服务间通过 Ribbon 或Feign 实现服务的消费以及均衡负载；通过 Spring Cloud Config 实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。

在该架构中，我们的服务集群包含：内部服务 Service A 和 Service B，他们都会注册与订阅服务至 Eureka Server，而 Open Service 是一个对外的服务，通过均衡负载公开至服务调用方。本文我们把焦点聚集在对外服务这块，这样的实现是否合理，或者是否有更好的实现方式呢？

先来说说这样架构需要做的一些事儿以及存在的不足：

- 首先，破坏了服务无状态特点。为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外可续对接口访问的控制处理。
- 其次，无法直接复用既有接口。当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。

面对类似上面的问题，我们要如何解决呢？

为了解决上面这些问题，我们需要**将权限控制这样的东西从我们的服务单元中抽离出去**，也就是服务网关（也成为 API 网关）。

**简单来说，API 网关是一个搭建在客户端和微服务之间的服务，我们可以在 API 网关中处理一些非业务功能的逻辑，例如权限验证、监控、缓存、请求路由等**。

**API 网关就像整个微服务系统的门面一样，是系统对外的唯一入口。有了它，客户端会先将请求发送到 API 网关，然后由 API 网关根据请求的标识信息将【请求转发】到微服务实例**。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019144519870.png)

对于服务数量众多、复杂度较高、规模比较大的系统来说，使用 API 网关具有以下好处：

- **客户端通过 API 网关与微服务交互时，客户端只需要知道 API 网关地址即可，而不需要维护大量的服务地址，简化了客户端的开发。**
- **客户端直接与 API 网关通信，能够减少客户端与各个服务的交互次数**。
- 客户端与后端的服务耦合度降低。
- 节省流量，提高性能，提升用户体验。
- API 网关还提供了安全、流控、过滤、缓存、计费以及监控等 API 管理功能。

常见的 API 网关实现方案主要有以下 5 种：

- Spring Cloud Gateway
- Spring Cloud Netflix Zuul
- Kong
- Nginx+Lua
- Traefik

本节，我们就对 Spring Cloud Netfilx Zuul 进行详细介绍。

## 构建服务网关

> 参考 https://blog.didispace.com/spring-cloud-starter-dalston-6-1/

使用Spring Cloud Zuul来构建服务网关的基础步骤非常简单，只需要下面几步：

- 创建一个基础的Spring Boot项目，命名为：`api-gateway`。并在`pom.xml`中引入依赖：

```xml
<parent>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-parent</artifactId>
  <version>1.5.4.RELEASE</version>
  <relativePath/>
</parent>

<dependencies>
  <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zuul</artifactId>
  </dependency>
  <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-eureka</artifactId>
  </dependency>
</dependencies>

<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-dependencies</artifactId>
      <version>Dalston.SR1</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
```

- 创建应用主类，并使用`@EnableZuulProxy`注解开启Zuul的功能。

```java
@EnableZuulProxy
@SpringCloudApplication
public class Application {
  
  public static void main(String[] args) {
    new SpringApplicationBuilder(Application.class).web(true).run(args);
  }
  
}
```

- 创建配置文件`application.yaml`，并加入服务名、端口号、eureka注册中心的地址：

```yaml
spring:
  application:
    name: api-gateway

server:
  port: 1101

eureka:
  client:
    serviceUrl:
      defaultZone: http://eureka.didispace.com/eureka/
```

到这里，一个基于Spring Cloud Zuul服务网关就已经构建完毕。启动该应用，一个默认的服务网关就构建完毕了。由于Spring Cloud Zuul在整合了Eureka之后，**具备默认的服务路由功能**，即：当我们这里构建的`api-gateway`应用启动并注册到 eureka 之后，服务网关会发现上面我们启动的两个服务`eureka-client`和`eureka-consumer`，这时候 Zuul 就会创建两个路由规则。每个路由规则都包含两部分，一部分是外部请求的匹配规则，另一部分是路由的服务 ID。针对当前示例的情况，Zuul 会创建下面的两个路由规则：

- 转发到`eureka-client`服务的请求规则为：`/eureka-client/**`
- 转发到`eureka-consumer`服务的请求规则为：`/eureka-consumer/**`

最后，我们可以通过访问`1101`端口的服务网关（注意这里是通过网关的 port，这也就是为什么说客户端只需要和网关进行交互就行了）来验证上述路由的正确性：

- 比如访问：http://localhost:1101/eureka-client/dc ，该请求将最终被路由到`eureka-client`的`/dc`接口上。

## 自定义服务路由配置

> 参考 http://blog.didispace.com/spring-cloud-starter-dalston-6-2/

Spring Cloud Zuul 通过与 Spring Cloud Eureka 的整合，实现了对服务实例的自动化维护，所以我们只需要通过一组 `zuul.routes.<route>.path` 与 `zuul.routes.<route>.serviceId` 参数对的方式即可对路由规则进行自定义的配置。

比如下面的示例，它实现了对符合`/user-service/**`规则的请求路径转发到名为`user-service` 的服务实例上去的路由规则。其中`<route>`可以指定为任意的路由名称。

```properties
# 请求路径
zuul.routes.user-service.path=/user-service/**
# 请求路径对应的服务实例
zuul.routes.user-service.serviceId=user-service
```

对于面向服务的路由配置，除了使用`path`与`serviceId`映射的配置方式之外，还有一种更简洁的配置方式：`zuul.routes.<serviceId>=<path>`，其中`<serviceId>`用来指定路由的具体服务名，`<path>`用来配置匹配的请求表达式。比如下面的例子，它的路由规则等价于上面通过`path`与`serviceId`组合使用的配置方式。

```
zuul.routes.user-service=/user-service/**
```

传统路由的映射方式比较直观且容易理解，API网关直接根据请求的URL路径找到最匹配的`path`表达式，直接转发给该表达式对应的`url`或对应`serviceId`下配置的实例地址，以实现外部请求的路由。那么当采用`path`与`serviceId`以服务路由方式实现时候，没有配置任何实例地址的情况下，外部请求经过API网关的时候，它是如何被解析并转发到服务具体实例的呢？

在Spring Cloud Netflix中，Zuul巧妙的整合了Eureka来实现面向服务的路由。实际上，我们可以直接将API网关也看做是Eureka服务治理下的一个普通微服务应用。它除了会将自己注册到Eureka服务注册中心上之外，也会从注册中心获取所有服务以及它们的实例清单。所以，在Eureka的帮助下，API网关服务本身就已经维护了系统中所有serviceId与实例地址的映射关系。当有外部请求到达API网关的时候，根据请求的URL路径找到最佳匹配的`path`规则，API网关就可以知道要将该请求路由到哪个具体的`serviceId`上去。由于在API网关中已经知道`serviceId`对应服务实例的地址清单，那么只需要通过Ribbon的负载均衡策略，直接在这些清单中选择一个具体的实例进行转发就能完成路由工作了。

## 过滤器

> 参考 https://blog.didispace.com/spring-cloud-starter-dalston-6-3/

通过上面所述，我们已经能够实现请求路由功能，微服务应用提供的接口就可以通过统一的API网关入口被客户端访问到了。但是，每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都需要有一定的限制，系统并不会将所有的微服务接口都对它们开放。

然而，目前的服务路由并没有限制权限这样的功能，所有请求都会被毫无保留地转发到具体的应用并返回结果，为了实现对客户端请求的安全校验和权限控制，最简单和粗暴的方法就是为每个微服务应用都实现一套用于校验签名和鉴别权限的过滤器或拦截器。不过，这样的做法并不可取，它会增加日后的系统维护难度，因为同一个系统中的各种校验逻辑很多情况下都是大致相同或类似的，这样的实现方式会使得相似的校验逻辑代码被分散到了各个微服务中去，冗余代码的出现是我们不希望看到的。**所以，比较好的做法是将这些校验逻辑剥离出去，构建出一个独立的鉴权服务。在完成了剥离之后，有不少开发者会直接在微服务应用中通过调用鉴权服务来实现校验，但是这样的做法仅仅只是解决了鉴权逻辑的分离，并没有在本质上将这部分不属于业余的逻辑拆分出原有的微服务应用，冗余的拦截器或过滤器依然会存在**。

> 简单来说就是鉴权这个东西也得做成一个服务

对于这样的问题，更好的做法是通过前置的网关服务来完成这些非业务性质的校验。由于网关服务的加入，外部客户端访问我们的系统已经有了统一入口，既然这些校验与具体业务无关，那何不**在请求到达的时候就完成校验和过滤，而不是转发后再过滤而导致更长的请求延迟**。同时，通过在网关中完成校验和过滤，微服务应用端就可以去除各种复杂的过滤器和拦截器了，这使得微服务应用的接口开发和测试复杂度也得到了相应的降低。

为了在API网关中实现对客户端请求的校验，我们将需要使用到Spring Cloud Zuul的另外一个核心功能：**过滤器**。

Zuul允许开发者在API网关上通过定义过滤器来实现对请求的拦截与过滤，实现的方法非常简单，我们只需要继承`ZuulFilter`抽象类并实现它定义的四个抽象函数就可以完成对请求的拦截和过滤了。

比如下面的代码，我们定义了一个简单的Zuul过滤器，它实现了在请求被路由之前检查HttpServletRequest中是否有accessToken参数，若有就进行路由，若没有就拒绝访问，返回401 Unauthorized错误。

```java
public class AccessFilter extends ZuulFilter  {

    private static Logger log = LoggerFactory.getLogger(AccessFilter.class);

    @Override
    public String filterType() {
        return "pre";
    }

    @Override
    public int filterOrder() {
        return 0;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

      	log.info("send {} request to {}", request.getMethod(), request.getRequestURL().toString());

        Object accessToken = request.getParameter("accessToken");
        if(accessToken == null) {
            log.warn("access token is empty");
            ctx.setSendZuulResponse(false);
            ctx.setResponseStatusCode(401);
            return null;
        }
        log.info("access token ok");
        return null;
    }

}
```

在上面实现的过滤器代码中，我们通过继承`ZuulFilter`抽象类并重写了下面的四个方法来实现自定义的过滤器。这四个方法分别定义了：

- `filterType`：过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。这里定义为`pre`，代表会在请求被路由之前执行。
- `filterOrder`：过滤器的执行顺序。当请求在一个阶段中存在多个过滤器时，需要根据该方法返回的值来依次执行。
- `shouldFilter`：判断该过滤器是否需要被执行。这里我们直接返回了`true`，因此该过滤器对所有请求都会生效。实际运用中我们可以利用该函数来指定过滤器的有效范围。
- `run`：过滤器的具体逻辑。

**在实现了自定义过滤器之后，它并不会直接生效，我们还需要为其创建具体的 Bean 才能启动该过滤器**，比如，在应用主类中增加如下内容：

```java
@EnableZuulProxy
@SpringCloudApplication
public class Application {

	public static void main(String[] args) {
		new SpringApplicationBuilder(Application.class).web(true).run(args);
	}

	@Bean
	public AccessFilter accessFilter() {
		return new AccessFilter();
	}
}
```

在对`api-gateway`服务完成了上面的改造之后，我们可以重新启动它，并发起下面的请求，对上面定义的过滤器做一个验证：

- `http://localhost:1101/api-a/hello`：返回401错误
- `http://localhost:1101/api-a/hello&accessToken=token`：正确路由到`hello-service`的`/hello`接口，并返回`Hello World`

到这里，对于Spring Cloud Zuul过滤器的基本功能就以介绍完毕。读者可以根据自己的需要在服务网关上定义一些与业务无关的通用逻辑实现对请求的过滤和拦截，比如：签名校验、权限校验、请求限流等功能。