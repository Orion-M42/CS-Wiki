> 参考 http://c.biancheng.net/springcloud/config.html

在分布式微服务系统中，几乎所有服务的运行都离不开配置文件的支持，这些配置文件通常由各个服务自行管理，以 properties 或 yml 格式保存在各个微服务的类路径下，例如 application.properties 或 application.yml 等。

这种将配置文件散落在各个服务中的管理方式，存在以下问题：

- **管理难度大**：配置文件散落在各个微服务中，难以管理。
- **安全性低**：配置跟随源代码保存在代码库中，容易造成配置泄漏。
- **时效性差**：微服务中的配置修改后，必须重启服务，否则无法生效。
- **局限性明显**：无法支持动态调整，例如日志开关、功能开关。

为了解决这些问题，通常我们都会使用配置中心对配置进行统一管理。市面上开源的配置中心有很多，例如百度的 Disconf、淘宝的 diamond、360 的 QConf、携程的 Apollo 等都是解决这类问题的。Spring Cloud 也有自己的分布式配置中心，那就是 Spring Cloud Config。

## 什么是 Spring Cloud Config

Spring Cloud Config 是由 Spring Cloud 团队开发的项目，它可以为微服务架构中各个微服务提供集中化的外部配置支持。

简单点说就是，Spring Cloud Config 可以将各个微服务的配置文件集中存储在一个外部的存储仓库或系统（例如 Git 、SVN 等）中，对配置的统一管理，以支持各个微服务的运行。

Spring Cloud Config 包含以下两个部分：

- Config Server：也被称为分布式配置中心，它是一个独立运行的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密信息和解密信息的访问接口。
- Config Client：指的是微服务架构中的各个微服务，它们通过 Config Server 对配置进行管理，并从 Config Sever 中获取和加载配置信息。

**Spring Cloud Config 默认使用 Git 存储配置信息**，因此使用 Spirng Cloud Config 构建的配置服务器天然就支持对微服务配置的版本管理。我们可以使用 Git 客户端工具方便地对配置内容进行管理和访问。除了 Git 外，Spring Cloud Config 还提供了对其他存储方式的支持，例如 SVN、本地化文件系统等。

Spring Cloud Config 工作原理如下图

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221019124333745.png)

Spring Cloud Config 工作流程如下：

1. 开发或运维人员提交配置文件到远程的 Git 仓库。
2. Config 服务端（分布式配置中心）负责连接配置仓库 Git，并**对 Config 客户端暴露获取配置的接口**。
3. **Config 客户端通过 Config 服务端暴露出来的接口，拉取配置仓库中的配置**。
4. Config 客户端获取到配置信息，以支持服务的运行

Spring Cloud Config 具有以下特点：

- Spring Cloud Config 由 Spring Cloud 团队开发，可以说是 Spring 的亲儿子，能够与 Spring 的生态体系无缝集成。
- Spring Cloud Config 将所有微服务的配置文件集中存储在一个外部的存储仓库或系统（例如 Git）中，统一管理。
- Spring Cloud Config 配置中心将配置以 REST 接口的形式暴露给各个微服务，以方便各个微服务获取。
- 微服务可以通过 Spring Cloud Config 向配置中心统一拉取属于它们自己的配置信息。
- 当配置发生变化时，微服务不需要重启即可感知到配置的变化，并自动获取和应用最新配置。
- 一个应用可能有多个环境，例如开发（dev）环境、测试（test）环境、生产（prod）环境等等，开发人员可以通过 Spring Cloud Config 对不同环境的各配置进行管理，且能够确保应用在环境迁移后仍然有完整的配置支持其正常运行。

## 代码示例

> 参考：
>
> - http://blog.didispace.com/spring-cloud-starter-dalston-3
> - https://blog.didispace.com/springcloud4-2/

### 准备配置仓库

- 准备一个git仓库，可以在码云或Github上创建都可以。比如本文准备的仓库示例：http://git.oschina.net/didispace/config-repo-demo
- 假设我们读取配置中心的服务/应用名为`config-client`，那么我们可以在git仓库中该项目的默认配置文件`config-client.yml`：

```
info:
  profile: default
```

- 为了演示加载不同环境的配置，我们可以在git仓库中再创建一个针对dev环境的配置文件 `config-client-dev.yml`：

```
info:
  profile: dev
```

### 构建配置中心

通过Spring Cloud Config来构建一个分布式配置中心非常简单，只需要三步：

- 创建一个基础的Spring Boot工程，命名为：`config-server-git`，并在`pom.xml`中引入下面的依赖（省略了parent和dependencyManagement部分）：

```xml
<dependencies>
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-config-server</artifactId>
	</dependency>
</dependencies>
```

- 创建Spring Boot的程序主类，并添加`@EnableConfigServer`注解，开启Spring Cloud Config的服务端功能。

```java
@EnableConfigServer
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		new SpringApplicationBuilder(Application.class).web(true).run(args);
	}

}
```

- 在`application.yml`中添加配置服务的基本信息以及配置中心的 Git 仓库的相关信息，例如：

```yml
spring
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: http://git.oschina.net/didispace/config-repo-demo/
server:
  port: 1201
```

到这里，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心就已经完成了。我们可以将该应用先启动起来，确保没有错误产生，然后再尝试下面的内容。

> 如果我们的Git仓库需要权限访问，那么可以通过配置下面的两个属性来实现；
> spring.cloud.config.server.git.username：访问Git仓库的用户名
> spring.cloud.config.server.git.password：访问Git仓库的用户密码

完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：

- /{application}/{profile}[/{label}]
- /{application}-{profile}.yml
- /{label}/{application}-{profile}.yml
- /{application}-{profile}.properties
- /{label}/{application}-{profile}.properties

上面的url会映射`{application}-{profile}.properties`对应的配置文件，其中`{label}`对应Git上不同的分支，默认为master。我们可以尝试构造不同的url来访问不同的配置内容，比如，要访问master分支上 config-client应用的dev环境，就可以访问这个url：`http://localhost:1201/config-client/dev/master`，并获得如下返回：

```json
{
    "name": "config-client",
    "profiles": [
        "dev"
    ],
    "label": "master",
    "version": null,
    "state": null,
    "propertySources": [
        {
            "name": "http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml",
            "source": {
                "info.profile": "dev"
            }
        },
        {
            "name": "http://git.oschina.net/didispace/config-repo-demo/config-client.yml",
            "source": {
                "info.profile": "default"
            }
        }
    ]
}
```

我们可以看到该Json中返回了应用名：config-client，环境名：dev，分支名：master，以及default环境和dev环境的配置内容。

### 构建客户端

在完成了上述验证之后，确定配置服务中心已经正常运作，下面我们尝试如何在微服务应用中获取上述的配置信息。

- 创建一个Spring Boot应用，命名为`config-client`，并在`pom.xml`中引入下述依赖：

```xml
<dependencies>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-config</artifactId>
	</dependency>
</dependencies>
```

- 创建Spring Boot的应用主类，具体如下：

```java
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		new SpringApplicationBuilder(Application.class).web(true).run(args);
	}

}
```

- 创建`bootstrap.yml`配置，来指定获取配置文件的`config-server-git`位置，例如：

```yml
spring:
  application:
    name: config-client
  cloud:
    # 从哪里拿配置
    config:
      uri: http://localhost:1201/
      profile: default
      label: master

server:
  port: 2001
```

上述配置参数与Git中存储的配置文件中各个部分的对应关系如下：

- spring.application.name：对应配置文件规则中的`{application}`部分
- spring.cloud.config.profile：对应配置文件规则中的`{profile}`部分
- spring.cloud.config.label：对应配置文件规则中的`{label}`部分
- spring.cloud.config.uri：配置中心`config-server`的地址

**这里需要格外注意：上面这些属性必须配置在bootstrap.properties中，这样config-server中的配置信息才能被正确加载。**

在完成了上面你的代码编写之后，读者可以将config-server-git、config-client都启动起来，然后访问http://localhost:2001/info ，我们可以看到该端点将会返回从git仓库中获取的配置信息：

```json
{
    "profile": "default"
}
```

我们可以通过 @Value 来获取配置：

```java
@RestController
public class TestController {

    @Value("${info.profile}")
    private String profile;

    @RequestMapping("/getProfile")
    public String getProfile() {
        return this.profile;
    }

}
```

### 配置中心高可用

通常在生产环境，Config Server与服务注册中心一样，我们也需要将其扩展为高可用的集群，作为架构内的配置管理，本身其实也是可以看作架构中的一个微服务。所以，常**见的方法就是把config-server也注册为服务，这样所有客户端就能以服务的方式进行访问。通过这种方法，只需要启动多个指向同一 Git 仓库位置的 config-server 就能实现高可用了**。

配置过程也非常简单，具体如下：

#### config-server配置

- 在`pom.xml`的dependencies节点中引入如下依赖，相比之前的config-server就，加入了`spring-cloud-starter-eureka`，用来注册服务

```xml
<dependencies>
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-config-server</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-eureka</artifactId>
	</dependency>
</dependencies>
```

- 在`application.properties`中配置参数`eureka.client.serviceUrl.defaultZone`以指定服务注册中心的位置，详细内容如下：

```properties
spring.application.name=config-server
server.port=7001
# 配置服务注册中心
eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
# git仓库配置
spring.cloud.config.server.git.uri=http://git.oschina.net/didispace/SpringCloud-Learning/
spring.cloud.config.server.git.searchPaths=Chapter1-1-8/config-repo
spring.cloud.config.server.git.username=username
spring.cloud.config.server.git.password=password
```

- 在应用主类中，新增`@EnableDiscoveryClient`注解，用来将config-server注册到上面配置的服务注册中心上去。

```java
@EnableDiscoveryClient
@EnableConfigServer
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		new SpringApplicationBuilder(Application.class).web(true).run(args);
	}

}
```

- 启动该应用，并访问`http://localhost:1111/`，可以在Eureka Server的信息面板中看到config-server已经被注册了。

[![img](https://blog.didispace.com/assets/4-3.png)](https://blog.didispace.com/assets/4-3.png)

#### config-client配置

- 同config-server一样，在`pom.xml`的dependencies节点中新增`spring-cloud-starter-eureka`依赖，用来注册服务：

```xml
<dependencies>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-config</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-eureka</artifactId>
	</dependency>
</dependencies>
```

- 在`bootstrap.properties`中，按如下配置：

```properties
spring.application.name=didispace
server.port=7002

# 指定服务注册中心
eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/
# 开启通过服务来访问Config Server的功能
spring.cloud.config.discovery.enabled=true
# 指定Config Server注册的服务名
spring.cloud.config.discovery.serviceId=config-server
spring.cloud.config.profile=dev
```

其中，通过`eureka.client.serviceUrl.defaultZone`参数指定服务注册中心，用于服务的注册与发现，再将`spring.cloud.config.discovery.enabled`参数设置为true，开启通过服务来访问Config Server的功能，最后利用`spring.cloud.config.discovery.serviceId`参数来指定Config Server注册的服务名。这里的`spring.application.name`和`spring.cloud.config.profile`如之前通过URI的方式访问时候一样，用来定位Git中的资源。

- 在应用主类中，增加`@EnableDiscoveryClient`注解，用来发现config-server服务，利用其来加载应用配置

```java
@EnableDiscoveryClient
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		new SpringApplicationBuilder(Application.class).web(true).run(args);
	}

}
```

- 加载Git中的配置信息

```java
@RefreshScope
@RestController
public class TestController {

    @Value("${info.profile}")
    private String profile;

    @RequestMapping("/getProfile")
    public String getProfile() {
        return this.profile;
    }

}
```

- 完成了上述配置之后，我们启动该客户端应用。若启动成功，访问`http://localhost:1111/`，可以在Eureka Server的信息面板中看到该应用已经被注册成功了。

[![img](https://blog.didispace.com/assets/4-4.png)](https://blog.didispace.com/assets/4-4.png)

- 访问客户端应用提供的服务：`http://localhost:7002/from`，此时，我们会返回在Git仓库中`didispace-dev.properties`文件配置的 info.profile 属性内容

### 配置刷新

有时候，我们需要对配置内容做一些实时更新的场景，那么Spring Cloud Config是否可以实现呢？答案显然是可以的。下面，我们看看如何进行改造来实现配置内容的实时更新。

在改造程序之前，我们先将config-server和config-client都启动起来，并访问客户端提供的REST API`http://localhost:7002/from`来获取配置信息，可以获得返回内容为：`git-dev-1.0`。接着，我们可以尝试使用Git工具修改当前配置的内容，比如，将`config-repo/didispace-dev.properties`中的from的值从`from=git-dev-1.0`修改为`from=git-dev-2.0`，再访问`http://localhost:7002/from`，可以看到其返回内容还是`git-dev-1.0`。

下面，我们将在config-client端增加一些内容和操作以实现配置的刷新：

- 在config-clinet的`pom.xml`中新增`spring-boot-starter-actuator`监控模块，其中包含了`/refresh`刷新API。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

- 重新启动config-clinet，访问一次`http://localhost:7002/from`，可以看到当前的配置值
- 修改Git仓库`config-repo/didispace-dev.properties`文件中`from`的值
- 再次访问一次`http://localhost:7002/from`，可以看到配置值没有改变
- 通过POST请求发送到`http://localhost:7002/refresh`，我们可以看到返回内容如下，代表`from`参数的配置内容被更新了

```
[
  "from"
]
```

- 再次访问一次`http://localhost:7002/from`，可以看到配置值已经是更新后的值了

通过上面的介绍，大家不难想到，**该功能可以同Git仓库的Web Hook功能进行关联，当有Git提交变化时，就给对应的配置主机发送`/refresh`请求来实现配置信息的实时更新。但是，当我们的系统发展壮大之后，维护这样的刷新清单也将成为一个非常大的负担，而且很容易犯错**

那么有什么办法可以解决这个复杂度呢？后续我们将继续介绍如何**通过Spring Cloud Bus来实现以消息总线的方式进行通知配置信息的变化，完成集群上的自动化更新**。