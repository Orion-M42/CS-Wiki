---
title: 什么是分布式 (草稿)
date: 2022-10-08 10:16:19
permalink: /pages/ed95f8/
---
## 什么是分布式

> 参考 https://doocs.gitee.io/advanced-java/#/./docs/distributed-system/distributed-system-interview

设计网站可扩展架构的核心思想是模块化，并在此基础之上，降低模块间的耦合性，提高模块的复用性。

所谓分布式业务系统，就是**把原来一个大块系统，拆分成多个独立的子系统，独立的子系统/模块部署在独立的服务器（集群）上**，从物理上分离模块之间的耦合关系，进一步降低耦合性提高复用性。**这些子系统/模块以消息传递及依赖调用的方式聚合成一个完整的系统**。

假设原来你做了一个 OA 系统，里面包含了权限模块、员工模块、请假模块、财务模块，一个工程，里面包含了一堆模块，模块与模块之间会互相去调用，1 台机器部署。现在如果你把这个系统给拆开，权限系统、员工系统、请假系统、财务系统 4 个系统，4 个工程，分别在 4 台机器上部署。一个请求过来，完成这个请求，这个员工系统，调用权限系统，调用请假系统，调用财务系统，4 个系统分别完成了一部分的事情，最后 4 个系统都干完了以后，才认为是这个请求已经完成了。

<img src="https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20201122165939.png" style="zoom:67%;" />

> 💡 **什么是集群 ？**
>
> <u>`集群（cluster）`就是一组计算机/服务器，它们作为一个整体向用户提供一组网络资源</u>，这些单个的计算机系统就是集群的`节点（node）`。
>
> 💡 **分布式与集群的区别是什么 ？**
>
> 集群是个物理形态，分布式是个工作方式。
>
> - **分布式：** 一个业务分拆多个子业务，部署在不同的服务器上
> - **集群：** 将几台服务器集中在一起，实现同一业务

## 为什么要分布式

从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加**便于维护和扩展**。

另外，将系统拆分成分布式之后不仅便于系统扩展和维护，更能**提高整个系统的性能**。（把整个系统拆分成不同的服务/系统，然后每个服务/系统 单独部署在一台服务器上，很大程度上提高了系统性能）

##  分布式系统的主要特征

> 参考 https://www.pdai.tech/md/arch/arch-z-theory.html#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81

无论空间上如何分布，一个标准的分布式系统应该具有以下几个主要特征

- **分布性**

  分布式系统中的多台计算机之间在空间位置上可以随意分布，同时，机器的分布情况也会随时变动。

- **对等性**

  分布式系统中的计算机没有主／从之分，即没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。

  副本（Replica）是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。在常见的分布式系统中，为了对外提供高可用的服务，我们往往会对数据和服务进行副本处理：

  - <u>数据副本</u>是指在不同节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取该数据，这是解决分布式系统数据丢失问题最为有效的手段。
  - 另一类副本是<u>服务副本</u>，指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理。

- **自治性**

  分布式系统中的各个节点都包含自己的处理机和内存，各自具有独立的处理数据的功能。通常，彼此在地位上是平等的，无主次之分，既能自治地进行工作，又能利用共享的通信线路来传送信息，协调任务处理。

- **并发性**

  在一个计算机网络中，程序运行过程的并发性操作是非常常见的行为。例如同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最大的挑战之一。

## 分布式系统面临的问题

> 参考 https://www.pdai.tech/md/arch/arch-z-theory.html#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98

- **缺乏全局时钟**

  在分布式系统中，<u>很难定义两个事件究竟谁先谁后</u>，原因就是因为分布式系统缺乏一个全局的时钟序列控制。

- **机器宕机**

  机器宕机是最常见的异常之一。在大型集群中每日宕机发生的概率为千分之一左右，在实践中，一台宕机的机器恢复的时间通常认为是24 小时，一般需要人工介入重启机器。

- **网络异常**
  - 消息丢失，两片节点之间彼此完全无法通信，即出现了“网络分化”；
  - 消息乱序，有一定的概率不是按照发送时的顺序依次到达目的节点，考虑使用序列号等机制处理网络消息的乱序问题，使得无效的、过期的网络消息不影响系统的正确性；
  - 数据错误；不可靠的TCP，TCP 协议为应用层提供了可靠的、面向连接的传输服务，但在分布式系统的协议设计中不能认为所有网络通信都基于TCP 协议则通信就是可靠的。TCP协议只能保证同一个TCP 链接内的网络消息不乱序，TCP 链接之间的网络消息顺序则无法保证。

- **分布式三态**

  如果某个节点向另一个节点发起RPC(Remote procedure call)调用，即某个节点A 向另一个节点B 发送一个消息，节点B 根据收到的消息内容完成某些操作，并将操作的结果通过另一个消息返回给节点A，那么这个RPC 执行的结果有三种状态：“成功”、“失败”、“超时（未知）”，称之为分布式系统的三态。

- **存储数据丢失**

  对于有状态节点来说，数据丢失意味着状态丢失，通常只能从其他节点读取、恢复存储的状态。 

  异常处理原 - 被大量工程实践所检验过的异常处理黄金原则是：任何在设计阶段考虑到的异常情况一定会在系统实际运行中发生，但在系统实际运行遇到的异常却很有可能在设计时未能考虑，所以，除非需求指标允许，在系统设计时不能放过任何异常情况。

## 衡量分布式系统的指标

> 参考 https://www.pdai.tech/md/arch/arch-z-theory.html#%E8%A1%A1%E9%87%8F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8C%87%E6%A0%87

- **性能**

  系统的吞吐能力，指系统在某一时间可以处理的数据总量，通常可以用系统每秒处理的总的数据量来衡量；系统的响应延迟，指系统完成某一功能需要使用的时间；系统的并发能力，指系统可以同时完成某一功能的能力，通常也用 QPS(query per second)来衡量。上述三个性能指标往往会相互制约，追求高吞吐的系统，往往很难做到低延迟；系统平均响应时间较长时，也很难提高 QPS。

- **可用性**

  系统的可用性(availability)指系统在面对各种异常时可以正确提供服务的能力。系统的可用性可以用系统停服务的时间与正常服务的时间的比例来衡量，也可以用某功能的失败次数与成功次数的比例来衡量。可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。

- **可扩展性**

  系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性。<u>好的分布式系统总在追求“线性扩展性”，也就是使得系统的某一指标可以随着集群中的机器数量线性增长</u>。

- **一致性**

  分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。越是强的一致的性模型，对于用户使用来说使用起来越简单

## 分布式一致性

> 参考：https://juejin.cn/post/6874599410802622472

分布式数据一致性，指的是数据在多份副本中存储时，各副本中的数据是一致的。

分布式系统当中，数据往往会有多个**副本**。如果是一台数据库处理所有的数据请求，那么通过`ACID四原则`，基本 可以保证数据的一致性。而`多个副本`就需要保证数据会有`多份拷贝`。这就带来了同步的问题，因为我们几乎没有办 法保证可以`同时更新所有机器`当中的包括备份所有数据。 `网络延迟`，即使我在同一时间给所有机器发送了更新数据 的请求，也不能保证这些请求被响应的时间保持一致`存在时间差`，就会存在某些机器之间的`数据不一致`的情况。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04507f96da334e5fb0b972d6ccddb87e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp) 

总得来说，我们无法找到一种能够满足分布式系统所有系统属性的分布式一致性解决方案。因此，如何既保证数据 的一致性，同时又不影响系统运行的性能，是每一个分布式系统都需要重点考虑和权衡的。于是，一致性级别由此诞生：

1）**强一致性**：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往 对系统的性能影响大。但是强一致性很难实现

2）**弱一致性**：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致， 但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态

- **读写一致性**：用户读取自己写入结果的一致性，保证用户永远能够第一时间看到自己更新的内容。 比如我们发一条朋友圈，朋友圈的内容是不是第一时间被朋友看见不重要，但是一定要显示在自己的列表上. 

  解决方案:  

  - 方案1：一种方案是对于一些特定的内容我们每次都去主库读取。 （问题主库压力大）  
  - 方案2：我们设置一个更新时间窗口，在刚刚更新的一段时间内，我们默认都从主库读取，过了这个窗口之后，我们会挑 选最近有过更新的从库进行读取  
  - 方案3：我们直接记录用户更新的时间戳，在请求的时候把这个时间戳带上，凡是最后更新时间小于这个时间戳的从库都 不予以响应

- **单调读一致性**：本次读到的数据不能比上次读到的旧。 由于主从节点更新数据的时间不一致，导致用户在不停地刷新的时候，有时候能刷出来，再次刷新之后请求被负载均衡到其他节点上，用户就会发现数据不见了，再刷新又可能再刷出来，就好像遇见灵异事件一样 

  解决方案: 

  - 就是根据用户 ID 计算一个 Hash 值，再通过 Hash 值映射到机器。同一个用户不管怎么刷新，都只会被映射到同 一台机器上。这样就保证了不会读到其他从库的内容，带来用户体验不好的影响。

- **因果一致性**：如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后 的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制

- **最终一致性**：最终一致性是所有分布式一致性模型当中最弱的。可以认为是没有任何优化的“最”弱一致性，它的意思是说，我不考虑 所有的中间状态的影响，只保证当没有新的更新之后，经过一段时间之后，最终系统内所有副本的数据是正确的。 它<u>最大程度上保证了系统的并发能力</u>，也因此，在高并发的场景下，它也是使用最广的一致性模型