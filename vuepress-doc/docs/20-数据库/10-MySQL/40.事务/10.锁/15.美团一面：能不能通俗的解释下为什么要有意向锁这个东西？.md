众所周知，InnoDB 中既有读锁也有写锁，也称为共享锁和排他锁，这两种锁既可以加在整张表上，也可以加在行上。

MySQL 自身就提供了**表锁**的能力：

- 读锁：`LOCK TABLE table_name READ` 用读锁锁表，会阻塞其他事务的写操作
- 写锁：`LOCK TABLE table_name WRITE` 用写锁锁表，会阻塞其他事务的读和写操作

**行锁**是 InnoDB 存储引擎提供的，MySQL 本身并不提供行级锁的能力：

- 读锁，如 `SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE` 加行级读锁，会阻塞其他事务对该行记录的写操作
- 写锁，如 `SELECT * FROM table_name WHERE ... FOR UPDATE` 加行级写锁，会阻塞其他事务对该行记录的的读和写操作

又有表锁又有行锁，我们来考虑下这两种类型的锁共存的问题。看下面这个例子：

事务 A 加了**行级读锁**，锁住了表中的一行，让这一行只能读，不能写。

之后，事务 B 尝试申请**整个表的写锁**。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221226224005068.png)

如果事务 B 申请成功，那么理论上它就能修改表中的任意一行，这与 A 持有的行级读锁是冲突的。

数据库需要避免这种冲突，就势必要让 B 的申请被阻塞，直到 A 释放行级读锁。

那数据库要怎么判断这个冲突呢？

- 步骤 1：判断表是否已被其他事务用表级锁锁住了整张表
- 步骤 2：判断表中的每一行是否已被行级锁锁住

看起来没有什么困难的，但请注意步骤 2，判断表中的每一行，各位，如何判断？

显然，需要遍历！遍历表中的每一行。

小学生都能想到这样的判断方法效率实在太过于低下了。

于是就有了意向锁！

<br>

我们先来看下意向锁的解释：

> Intention locks are **table-level locks** that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table. 

意向锁是一个**表级锁**，其作用就是指明接下来的事务将会用到哪种锁。

有两种意向锁：

- **意向共享锁/读锁（IS Lock）**：当事务想要获得一张表中某几行的读锁（行级读锁）时，InnoDB 存储引擎会**自动**地先获取该表的意向读锁（表级锁）
- **意向排他锁/写锁（IX Lock）**：当事务想要获得一张表中某几行的写锁（行级写锁）时，InnoDB 存储引擎会**自动**地先获取该表的意向写锁（表级锁）

> 注意这里的自动：申请意向锁的动作是数据库完成的，就是说，事务 A 申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。

在意向锁存在的情况下，事务 A 如果想申请行级读锁，就必须先申请该表的意向读锁，申请成功后才能继续申请某行记录的行级读锁。

在意向锁存在的情况下，上面的判断可以改成：

- 步骤 1（不变）：判断表是否已被其他事务用表级锁锁住了整张表
- 步骤 2：发现表上有意向读锁（说明表中有些行被行级读锁锁住了），意向读锁和表级写锁互斥，因此，事务 B 申请表的写锁会被阻塞。

也就是说原先步骤 2 的遍历表中每一行的操作，简化成了判断下整张表上有无表级意向锁就行了，效率大幅提升。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221226224333550.png)

这就是为什么要有意向锁了。