---
date: 2022-10-02 15:58:46
permalink: /pages/130353/
---
高并发这个阶段，肯定是做读写分离的，因为**实际上大部分的网站或者是 app 其实都是读多写少**。针对这个情况，**利用读写分离可以大幅提升读的性能，从而支撑更高的读并发压力了**

## 如何实现 MySQL 的读写分离

**读写分离的基本原理是将数据库【读操作】分散到不同的【从节点】上**，下面是其基本架构图。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221002165708917.png)

读写分离的基本实现是：

- 数据库服务器搭建主从集群，一主一从、一主多从都可以
- 数据库主机负责读写操作，从机只负责读操作
- 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据
- 业务服务器将写操作发给数据库主机，将读操作发给数据库从机

> 需要注意的是，这里用的是“主从集群”，而不是“主备集群”。
>
> - “从机”的“从”可以理解为“仆从”，仆从是要帮主人干活的，“从机”是需要提供读数据的功能的；
> - **而“备机”一般被认为仅仅提供备份功能，不提供访问功能**。
>
> 所以使用“主从”还是“主备”，是要看场景的，这两个词并不是等同的

读写分离的实现逻辑并不复杂，但我们需要解决一个问题：**主从延迟同步问题**

如果业务服务器将数据写入到数据库主服务器后立刻（1 秒内）进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。

例如，**用户刚注册完（数据插入到主库）后立刻登录（查询的是从库），业务服务器会提示他“你还没有注册”，而用户明明刚才已经注册成功了**。

> 导致从库延迟的几种情况： 
>
> - 从库物理硬件比主库差
> - 从库查询压力大
> - 从库上面有大查询
> - 从库的表上没有索引
> - 主库上面有一个长事务
> - 主库上面的热点表有DDL操作
> - 从库的空间不足
> - 从库的并行复制能力不足
> - 从库上面正在做备份操作

## MySQL 主从复制的原理

> 参考 https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E4%B9%88

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221002185317979.png)

1. 主库将数据库中数据的变化写入到 binlog
2. 从库连接主库
3. 从库会创建一个 I/O 线程向主库请求更新的 binlog
4. 主库会创建一个 **binlog dump 线程**来发送 binlog ，从库中的 I/O 线程负责接收
5. 从库的 **I/O 线程**将接收的 binlog 写入到 **relay log** 中。
6. 从库的 **SQL 线程**读取 relay log 同步数据本地（也就是再执行一遍 SQL ）

重点理解：**从库的 relay log 存储的是接收到的主库事务，从库的 bin log 存储的是已经执行完成了的事务**

## 解决主从同步延时问题

上文我们已经说过，所谓主从同步延时就是：高并发场景下，刚写入主库的数据在从库上可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。

**MySQL 主从延时排查方法**：

MySQL 有主从同步的状态信息，可以通过 MySQL 命令 `show slave status` 获取，除了获知当前是否主从同步正常工作，另外一个重要指标就是 `Seconds_Behind_Master`，根据输出的 `Seconds_Behind_Master` 参数的值来判断：

- `NULL`：表示 io_thread 或是 sql_thread 有任何一个发生故障
- `0`：该值为零，表示主从复制良好，无延迟
- `正值`：表示主从已经出现延时，数字越大表示从库延迟越严重

一般来说，如果主从延迟较为严重，有以下**解决方案**：

> 参考：https://time.geekbang.org/column/article/77636

- 强制走主库方案；
- sleep 方案；
- 判断主备无延迟方案；
- 配合 semi-sync 方案；
- 等主库位点方案；
- 等 GTID 方案

### 强制走主库方案

强制走主库方案其实就是，将查询请求做分类

- **对于必须要拿到最新结果的请求，强制将其发到主库上**。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库
- **对于可以读到旧数据的请求，才将其发到从库上**。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。

你可能会说，这个方案是不是有点畏难和取巧的意思，但其实**这个方案是用得最多的**

当然，这个方案最大的问题在于，有时候你会碰到 “所有查询都必须立即拿到最新结果” 的需求，比如一些金融类的业务。这样的话，你可能会选择放弃读写分离，所有读写压力都在主库，等同于放弃了扩展性

因此接下来，我们来讨论的话题是：在读写分离的场景下，有哪些解决主从同步延迟的方案，并分析各个方案的优缺点

### sleep 方案

主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 select sleep(1) 命令。

这个方案的假设是，大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。

这个方案给你的第一感觉，很可能是不靠谱儿，应该不会有人用吧？并且，你还可能会说，直接在发起查询时先执行一条 sleep 语句，用户体验很不友好啊。

但，这个思路确实可以在一定程度上解决问题。为了看起来更靠谱儿，我们可以换一种方式。

以卖家发布商品为例

- <u>商品发布后，用 Ajax（Asynchronous JavaScript + XML，异步 JavaScript 和 XML）直接把客户端输入的内容作为“新的商品”显示在页面上，而不是真正地去数据库做查询。这样，卖家就可以通过这个显示，来确认产品已经发布成功了</u>
- 卖家再刷新页面，去查看商品的时候，其实已经过了一段时间，也就达到了 sleep 的目的

这个 sleep 方案确实解决了类似场景下的主从同步延迟问题。但，从严格意义上来说，这个方案存在的问题就是不精确。这个不精确包含了两层意思：

- 如果这个查询请求本来 0.5 秒就可以在从库上拿到正确结果，也会等 1 秒
- 如果延迟超过 1 秒，从库上读到的仍然是旧数据

接下来我就和你介绍一些更准确的方案

### 判断主备无延迟方案

前面我们提到 `show slave status` 结果里的 `seconds_behind_master` 参数的值可以用来衡量主备延迟时间的长短。

所以第一种确保主备无延迟的方法是，**每次从库执行查询请求前，先判断 `seconds_behind_master` 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求**。

seconds_behind_master 的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和 GTID 的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。

如图 3 所示，是一个 show slave status 结果的部分截图

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221002201622163.png)

第二种方法，**对比位点**确保主备无延迟：

- Master_Log_File 和 Read_Master_Log_Pos，表示的是从库读到的主库的最新位点
- Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是从库执行的最新位点

如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。

第三种方法，**对比 GTID 集合**确保主从无延迟：

> https://blog.51cto.com/u_15018708/2557341
>
> 全局事务标识符（Global Transaction Identifier, GTID）是【**MySQL 5.6**】版本开始在主从复制方面推出的重要特性，它是一个已提交事务的编号，并且是全局唯一编号，不仅是在主库上，在给定的复制设置中的所有数据库上，它都是唯一的。
>
> GTID是由 server_uuid 和事务 id 组成，格式为 GTID=server_uuid:transaction_id。其中 server_uuid 是数据库启动时自动生成的，存放在数据库目录下的auto.cnf文件中，transaction_id是事务提交时由系统顺序分配的序列号

- Auto_Position=1 ，表示这对主从关系使用了 GTID 协议
- Retrieved_Gtid_Set，是<u>从库收到</u>的所有日志的 GTID 集合
- Executed_Gtid_Set，是<u>从库所有已经执行完成</u>的 GTID 集合

如果这两个集合相同，也表示备库接收到的日志都已经同步完成。



很显然，这两个方案都存在一个问题，就是**主库还没传到从库的的事务是没法判断的**

一个事务的 binlog 在主备库之间的状态：

- 主库执行完成，写入 binlog，并反馈给客户端；
- binlog 被从主库发送给备库，备库收到；
- 在备库执行 binlog 完成

不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。

举个例子，主库上执行完成了三个事务 trx1、trx2 和 trx3，其中：trx1 和 trx2 已经传到从库，并且已经执行完成了；trx3 在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。

如果这时候你在从库 B 上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但还是查不到 trx3 的。严格地说，读到的从库数据就是旧数据

要解决这个问题，就要引入**半同步复制**，也就是 semi-sync replication。

### 配合 semi-sync 方案

semi-sync 做了这样的设计：

- 事务提交的时候，主库把 binlog 发给从库；
- **从库收到 binlog 以后，发回给主库一个 ack，表示收到了**；
- 主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。

也就是说，如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了从库已经收到了这个日志。

换句话说，如果主库掉电的时候，有些 binlog 还来不及发给从库，此时若开启了 semi-sync，就不会导致系统数据丢失

这样，semi-sync 配合前面关于位点/GTID 集合的判断，就能够确定在从库上执行的查询请求，可以避免读到从库旧数据。



但是，semi-sync+ 位点判断的方案，只对一主一从的场景是成立的。**在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认**。这时，在从库上执行查询请求，就有两种情况：

- 如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据；
- 但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生读到从库旧数据的问题。

另外，判断同步位点的方案还有另外一个潜在的问题，即：**如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况**。

实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到“主从完全同步”。为什么这么说呢？我们来看一下这个时序图。

![img](https://static001.geekbang.org/resource/image/9c/09/9cf54f3e91dc8f7b8947d7d8e384aa09.png?wh=1142*880)

图 5 所示，就是等待位点方案的一个 bad case。

图中从库 B 下的虚线框，分别表示 relaylog 和 binlog 中的事务。可以看到，图 5 中从状态 1 到状态 4，一直处于延迟一个事务的状态（bin log 中的 trx 数量 < relay log，说明有些事务没有被执行）。备库 B 一直到状态 4 都和主库 A 存在延迟，如果用上面必须等到无延迟才能查询的方案，select 语句直到状态 4 都不能被执行。

但是，其实客户端是在发完 trx1 更新后发起的 select 语句，我们只需要确保 trx1 已经执行完成就可以执行 select 语句了（不需要等到 trx2 的执行）。也就是说，如果在状态 3 执行查询请求，得到的就是预期结果了。

到这里，我们小结一下，semi-sync 配合判断主备无延迟的方案，存在两个问题：

- 一主多从的时候，在某些从库执行查询请求会存在过期读的现象；
- 在持续延迟的情况下，可能出现过度等待的问题。

接下来，我要和你介绍的等主库位点方案，就可以解决这两个问题。

### 等主库位点方案

要理解等主库位点方案，我需要先和你介绍一条命令：

```sql
select master_pos_wait(file, pos[, timeout]);
```

这条命令的逻辑如下：

- 它是在从库执行的；
- 参数 file 和 pos 指的是主库上的文件名和位置；
- timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。

这个命令返回的结果如下：

- **一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务**
- 如果执行期间，备库同步线程发生异常，则返回 NULL；
- 如果等待超过 N 秒，就返回 -1；
- 如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。

对于上图中先执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：

- trx1 事务更新完成后，马上执行 `show master statu`s 得到当前主库执行到的 file 和 pos；
- 选定一个从库执行查询语句；
- 在从库上执行 select master_pos_wait(file, pos, 1)；这里我们假设，这条 select 查询最多在从库上等待 1 秒。那么，如果 1 秒内 master_pos_wait 返回一个大于等于 0 的整数，就确保了从库肯定已经执行了 trx1 事务，所以可以去从库执行查询；否则，到主库执行查询语句

![](https://static001.geekbang.org/resource/image/b2/57/b20ae91ea46803df1b63ed683e1de357.png?wh=1142*880)

到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。

你可能会说，如果所有的从库都延迟超过 1 秒了，那查询压力不就都跑到主库上了吗？确实是这样。但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。

具体怎么选择，就需要业务开发同学做好限流策略了

### 等 GTID 方案

如果你的数据库开启了 GTID 模式，对应的也有等待 GTID 的方案。

MySQL 中同样提供了一个类似的命令：

```sql
 select wait_for_executed_gtid_set(gtid_set, 1);
```

这条命令的逻辑是：**等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；超时返回 1**。

在前面等位点的方案中，我们执行完事务后，还要主动去主库执行 show master status。而【**MySQL 5.7.6**】版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端（API：`mysql_session_track_get_first` ），这样等 GTID 的方案就可以减少一次查询。这时，等 GTID 的执行流程就变成了：

- trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；
- 选定一个从库执行查询语句；在从库上执行 `select wait_for_executed_gtid_set(gtid1, 1);`，如果返回值是 0，则在这个从库执行查询语句；否则，到主库执行查询语句

![](https://static001.geekbang.org/resource/image/d5/39/d521de8017297aff59db2f68170ee739.png?wh=1142*880)

跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑

## 总结

在实际应用中，这几个方案是可以混合使用的。比如，先在客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等 GTID 或等位点的方案

## References

- https://time.geekbang.org/column/article/77636
- https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/14%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%EF%BC%9A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.md
- [Github - JavaGuide](https://snailclimb.gitee.io/javaguide/#/?id=%e7%bc%96%e7%a0%81%e4%b9%8b%e9%81%93%e5%bf%85%e7%9c%8b-1)