四猿外大佬写的文章：[读写分离水太深，你把握不住，让叔来——命令查询权责分离模式](https://mp.weixin.qq.com/s/XG0Qqpw6ivdjCcnHd-JBGg)

这里先简单做个摘录：

背景需求：

- 广告排行榜功能，根据消费的金额和点击次数等指标来排序
- 排名要能实时的根据消费金额和点击次数等指标的变化而变化

### 什么是 CQRS？

先来看传统的读写分离架构：

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221002183204182.png)

存在的问题：实际测试下来，总是有各种不满意的地方。其中最麻烦的就是**做排行榜由于用的指标比较多，就需要写很复杂的 SQL 去数据库中查询**。再加上个需要实时变化，那就得不停的去数据库中查询。读数据库的压力仍然非常大

而对于这种情况，我无论如何优化总是得不到满意的结果。如果我缓存这个排行呢，由于这个排行需要各种统计加排序，所以从数据库中查询出来后，还需要各种模型转换，如果并发量上来，查询再转换，性能真的掉的飞快。



什么是 CQRS？

CQRS 认为一套系统里的操作，总共就分为读和写两大类。如果一套系统不专门把读和写专门分开优化，那么系统就像我读书带着手机那样，会一心两用，从而因为彼此影响，导致各自的性能无法达到最优。

所以，读写应该专门的分开，并分别优化。

在 CQRS 里，**写这种行为被称为命令，而读行为被称为查询**。因为想让他们分开，所以 CQRS 模式中文翻译过来就被称为**命令查询权责分离模式**。

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221002183458379.png)

CQRS 和读写分离最根本的区别就在于：CQRS 读和写用的模型是不一样的！读写分离的读和写操作全都基于数据库，并且是同一个 Bean 对象。而 CQRS 读和写使用的模型是完全分开的：比如，写入数据由于不需要考虑读取，那我大可以使用 Json 格式，使用 XML 格式之类的非标准格式，甚至直接写个日志都可以。而读取数据则根本不需要考虑写入的问题，我甚至可以弄成一个容易搜索的索引格式来

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221002183702020.png)

- 数据统计就是广告排名需要的点击、消费等数据。这些数据会被放到一个单独的数据库中，这个数据库只用来写入，不考虑读
- 然后，展示广告排行的功能本身又会单独从缓存中把广告排行的模型直接读取出来展示出去，而不用专门再做什么转换了。也不存在什么复杂查询的问题。

但是，我们的需求是要准实时的让广告排行根据点击、消费等数据自动更新，**那么如果写入数据和读取数据模型分开了，该怎么办呢？**

这个简单，大家都能想到，就是消息队列~

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221002184001568.png)

当然引入消息队列之后就得保证这个消息的不丢失、不重复消费等等问题了

### CQRS 的缺点

**引入 CQRS 的模式后，最大的问题在于引入了过度的复杂性**。

由于需要读和写分开，那么我们开发的工作量无形中被加大了一倍。又引入 CQRS，这变得更复杂了。

因为我们发现，不同的功能，只有使用不同的读取或者写入模型才能充分用上 CQRS 的优点。

比如，广告排行可能使用了缓存中间件去存取现成的排名。根据关键字搜索各种合适的广告，可能就得考虑开源的搜索引擎中间件。每引入一种都会增加开发成本、服务器成本，以及更多的复杂度。

> 所以楼主最终没有广泛的采用 CQRS 模式，只是把最重要的功能点用上了 CQRS，防止系统复杂度爆炸