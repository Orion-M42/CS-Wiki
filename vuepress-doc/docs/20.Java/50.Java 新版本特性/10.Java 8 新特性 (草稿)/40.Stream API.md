---
title: Stream API
date: 2022-10-04 14:53:48
permalink: /pages/a11e44/
---
> 参考：
>
> - https://juejin.cn/post/6983835171145383967
> - https://juejin.cn/post/6986805369540444191#heading-5

## 为什么要使用 Stream

一切还要源于JDK8的发布，在那个函数式编程语言如火如荼的时代，Java由于它的臃肿而饱受诟病（强面向对象），社区迫切需要Java能加入函数式语言特点改善这种情况，终于在2014年Java发布了JDK8。

在JDK8中，我认为最大的新特性就是加入了函数式接口和lambda表达式，这两个特性取自函数式编程。

这两个特点的加入使Java变得更加简单与优雅，用函数式对抗函数式，巩固 Java 老大哥的地位，简直是师夷长技以制夷。

而 **Stream，就是 JDK8 依托于上面的两个特性（函数式接口、Lambda 表达式）为集合类库做的 一个类库，它能让我们通过 Lambda 表达式更简明扼要的以流水线的方式去处理集合内的数据，可以很轻松的完成诸如：过滤、分组、收集、归约这类操作，所以我愿将Stream称为函数式接口的最佳实践**。

### 更清晰的代码结构

Stream拥有更清晰的代码结构，为了更好的讲解Stream怎么就让代码变清晰了，这里假设我们有一个非常简单的需求：**在一个集合中找到所有大于2的元素** 。

先来看看没使用Stream之前：

```java
List<Integer> list = Arrays.asList(1, 2, 3);

List<Integer> filterList = new ArrayList<>();

for (Integer i : list) {
    if (i > 2) {
        filterList.add(i);
    }
}

System.out.println(filterList);
```

上面的代码很好理解，我就不过多解释了，其实也还好了，因为我们的需求比较简单，如果需求再多点呢？

每多一个要求，那么if里面就又要加一个条件了，而我们开发中往往对象上都有很多字段，那么条件可能有四五个，最后可能会变成这样：

```java
List<Integer> list = Arrays.asList(1, 2, 3);

List<Integer> filterList = new ArrayList<>();

for (Integer i : list) {
    if (i > 2 && i < 10 && (i % 2 == 0)) {
        filterList.add(i);
    }
}

System.out.println(filterList);
```

if 里面塞了很多条件，看起来就变得乱糟糟了，其实这也还好，最要命的是项目中往往有很多类似的需求，它们之间的区别只是某个条件不一样，那么你就需要复制一大坨代码，改吧改吧就上线了，这就导致代码里有大量重复的代码。

如果你 Stream，一切都会变得清晰易懂：

```java
List<Integer> list = Arrays.asList(1, 2, 3).stream()
        .filter(i -> i > 2)
        .filter(i -> i < 10)
        .filter(i -> i % 2 == 0)
        .collect(toList());
```

这段代码你只需要关注我们最关注的东西：筛选条件就够了，filter这个方法名能让你清楚的知道它是个过滤条件，collect 这个方法名也能看出来它是一个收集器，将最终结果收集到一个List里面去。

同时你可能发现了，为什么上面的代码中不用写循环？

因为 **Stream 会帮助我们进行隐式的循环**，这被称为【**内部迭代**】，与之对应的就是我们常见的外部迭代了。

所以就算你不写循环，它也会进行一遍循环。

### 不必关心变量状态 / 不可变

Stream在设计之初就被设计为`不可变的`，它的不可变有两重含义：

1. 由于**每次Stream操作都会生成一个新的Stream**，所以Stream是不可变的，就像String。
2. **在Stream中只保存原集合的引用，所以在进行一些会修改元素的操作时，是通过原元素生成一份新的新元素，所以Stream 的任何操作都不会影响到原对象**。

第一个含义可以帮助我们进行链式调用，实际上我们使用 Stream 的过程中往往会使用链式调用，而第二个含义则是函数式编程中的一大特点：不修改状态。

**无论对Stream做怎么样的操作，它最终都不会影响到原集合，它的返回值也是在原集合的基础上进行计算得来的**。

**所以在Stream中我们不必关心操作原对象集合带来的种种副作用，用就完了**

### 延迟执行与优化

Stream只在遇到`终结操作`的时候才会执行，比如：

```java
List.of(1, 2, 3).stream()
        .filter(i -> i > 2)
        .peek(System.out::println);
```

**这么一段代码是不会执行的**，peek 方法可以看作是 forEach，这里我用它来打印 Stream 中的元素。

因为 filter 方法和peek方法都是转换流方法，所以不会触发执行。

如果我们在后面加入一个count方法就能正常执行：

```java
List.of(1, 2, 3).stream()
        .filter(i -> i > 2)
        .peek(System.out::println)
        .count();
```

count方法是一个终结操作，用于计算出Stream中有多少个元素，它的返回值是一个long型。

**Stream的这种没有终结操作就不会执行的特性被称为`延迟执行`**。

与此同时，Stream还会对API中的无状态方法进行名为`循环合并`的优化，具体例子详见下文

## 创建 Stream

Stream的创建一般可以分为两种情况：

1. **使用Steam接口创建**
2. **通过集合类库创建**

同时还会讲一讲Stream的并行流与连接，都是创建Stream，却具有不同的特点。

### 通过Stream接口创建

Stream作为一个接口，它在接口中定义了定义了几个静态方法为我们提供创建Stream的API：

```java
public static<T> Stream<T> of(T... values) {
    return Arrays.stream(values);
}
```

首先是 of 方法，它提供了一个泛型可变参数，为我们创建了带有泛型的Stream流，同时在如果你的参数是基本类型的情况下会使用自动包装对基本类型进行包装：

```java
Stream<Integer> integerStream = Stream.of(1, 2, 3);

Stream<Double> doubleStream = Stream.of(1.1d, 2.2d, 3.3d);

Stream<String> stringStream = Stream.of("1", "2", "3");
```

当然，你也可以直接创建一个空的 Stream，只需要调用另一个静态方法——empty()，它的泛型是一个 Object：

```java
Stream<Object> empty = Stream.empty();
```

以上都是我们让我们易于理解的创建方式，还有一种方式可以创建一个无限制元素数量的 Stream——generate()：

```Java
public static<T> Stream<T> generate(Supplier<? extends T> s) {
    Objects.requireNonNull(s);
    return StreamSupport.stream(
            new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false);
}
```

从方法参数上来看，它接受一个函数式接口——Supplier作为参数，这个函数式接口是用来创建对象的接口，你可以将其类比为对象的创建工厂，Stream将从此工厂中创建的对象放入Stream中：

```java
Stream<String> generate = Stream.generate(() -> "Supplier");

Stream<Integer> generateInteger = Stream.generate(() -> 123);
```

我这里是为了方便直接使用Lamdba构造了一个Supplier对象，你也可以直接传入一个Supplier对象，它会通过Supplier接口的get() 方法来构造对象。

### 通过集合类库进行创建

相较于上面一种来说，第二种方式更较为常用，**我们常常对集合就行Stream流操作而非手动构建一个Stream**：

```java
Stream<Integer> integerStreamList = List.of(1, 2, 3).stream();

Stream<String> stringStreamList = List.of("1", "2", "3").stream(); 
```

在Java8中，集合的顶层接口`Collection`被加入了一个新的接口默认方法——`stream()`，通过这个方法我们可以方便的对所有集合子类进行创建Stream的操作：

```java
List<Integer> list = Arrays.asList(1, 2, 3);
Stream<Integer> listStream = list.stream();
```

通过查阅源码，可以发先 `stream()` 方法本质上还是通过调用一个Stream工具类来创建Stream：

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221005164706801.png)

### 创建并行流

在以上的示例中所有的Stream都是串行流，**在某些场景下，为了最大化压榨多核CPU的性能，我们可以使用并行流**，它通过JDK7中引入的fork/join框架来执行并行操作，我们可以通过如下方式创建并行流：

```java
Stream<Integer> integerParallelStream = Stream.of(1, 2, 3).parallel();
Stream<String> stringParallelStreamList = Arrays.asList(1, 2, 3).parallelStream();
```

是的，在Stream的静态方法中没有直接创建并行流的方法，我们需要在构造Stream后再调用一次parallel()方法才能创建并行流，因为调用parallel()方法并不会重新创建一个并行流对象，而是在原有的Stream对象上面设置了一个并行参数。

当然，我们还可以看到，Collection接口中可以直接创建并行流，只需要调用与`stream()` 对应的`parallelStream()`方法，就像我刚才讲到的，他们之间其实只有参数的不同：

```java
default Stream<E> stream() {
	return StreamSupport.stream(spliterator(), false);
}

default Stream<E> parallelStream() {
	return StreamSupport.stream(spliterator(), true);
}
```

**不过一般情况下我们并不需要用到并行流，在Stream中元素不过千的情况下性能并不会有太大提升，因为将元素分散到不同的CPU进行计算也是有成本的**。

并行的好处是充分利用多核CPU的性能，但是使用中往往要对数据进行分割，然后分散到各个CPU上去处理，如果我们使用的数据是数组结构则可以很轻易的进行分割，但是如果是链表结构的数据或者Hash结构的数据则分割起来很明显不如数组结构方便。

**所以只有当Stream中元素过万甚至更大时，选用并行流才能带给你更明显的性能提升**。

最后，当你有一个并行流的时候，你也可以通过`sequential()` 将其方便的转换成串行流：

```java
Stream.of(1, 2, 3).parallel().sequential();
```

### 连接Stream

如果你在两处构造了两个Stream，在使用的时候希望组合在一起使用，可以使用concat()：

```java
Stream<Integer> concat = Stream
        .concat(Stream.of(1, 2, 3), Stream.of(4, 5, 6));
```

如果是两种不同的泛型流进行组合，自动推断会自动的推断出两种类型相同的父类：

```java
Stream<Integer> integerStream = Stream.of(1, 2, 3);

Stream<String> stringStream = Stream.of("1", "2", "3");

Stream<? extends Serializable> stream = Stream.concat(integerStream, stringStream);
```

## Stream 转换流 API

Stream 中的所有 API 可以分成两类：

- **转换流操作** ：例如 filter 和 map 方法，将一个Stream转换成另一个Stream，返回值都**是** Stream。
- **终结流操作** ：例如 count 和 collect 方法，将一个Stream汇总为我们需要的结果，返回值都**不是** Stream

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221005165000454.png)

Stream  转换流操作的API 也分了两类：

- **无状态** ：即此方法的执行**无需**依赖前面方法执行的结果集。
- **有状态** ：即此方法的执行**需要**依赖前面方法执行的结果集。

### 无状态 API

在Stream中无状态的API我们常用的大概有以下三个：

1. `map()`方法：此方法的参数是一个 Function 对象，它可以使你对集合中的元素做自定义操作，并保留操作后的元素。
2. `filter()`方法：此方法的参数是一个 Predicate 对象，Predicate 的执行结果是一个Boolean类型，所以此方法只保留返回值为true的元素，正如其名我们可以使用此方法做一些筛选操作。
3. `flatMap()`方法：此方法和map()方法一样参数是一个Function对象，但是此Function的返回值要求是一个Stream，<u>该方法可以将多个Stream中的元素展平聚合在一起进行返回</u>。

#### map

先来看看一个map()方法的示例：

```java
Stream<Integer> integerStreamList = Arrays.asList(1, 2, 3).stream();

Stream<Integer> mapStream = integerStreamList.map(i -> i * 10);
```

我们拥有一个List，想要对其中的每个元素进行**乘10** 的操作，就可以采用如上写法，其中的`i`是对List中元素的变量名，`→` 后面的逻辑则是要对此元素进行的操作，以一种非常简洁明了的方式传入一段代码逻辑执行，这段代码最后会返回一个包含操作结果的新Stream。

这里为了更好的帮助大家理解，我画了一个简图：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2958e563168e4631b2e06a20487e9f7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

#### filter

接下来是filter()方法示例：

```java
Stream<Integer> integerStreamList = List.of(1, 2, 3).stream();

Stream<Integer> filterStream = integerStreamList.filter(i -> i >= 20);
```

在这段代码中会执行`i >= 20` 这段逻辑，然后将返回值为true的结果保存在一个新的Stream中并返回。

这里我也有一个简单的图示：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8d5acb58a414c7ab4fccc6c08918ead~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

#### flatMap()

根据官方文档的说法，此方法是为了进行一对多元素的平展操作：

举个例子，来源 https://blog.csdn.net/qq_31635851/article/details/112377797

这里我们有一份作家名单。每个作家都有一份书单。使用Stream.flatMap()我们将从所有作家那里得到所有书籍。然后我们会找到价格最高的那本书。

1.作家流对象.

```java
{
   {"Mohan",
    {
      {10,"AAA"}, {20,"BBB"}
    }
   },
   {"Sohan",
    {
      {30,"XXX"}, {15,"ZZZ"}
    }
   }
}
```

2.使用`flatMap(writer -> writer.getBooks().stream())`方法后，得到书单的流对象。

```java
{      
   {10,"AAA"}, 
   {20,"BBB"},
   {30,"XXX"}, 
   {15,"ZZZ"}
}
```

这里的结果被`flatMap()`方法展开。

3.使用`max(new BookComparator())`方法后，得到最贵的书籍。

```java
{30,"XXX"}
```

下面我们来看代码

**FlatmapWithList.java**

```java
public class FlatmapWithList {
    public static void main(String[] args) {
    	List<Book> books = Arrays.asList(new Book(10, "AAA"), new Book(20, "BBB"));
    	Writer w1 = new Writer("Mohan", books);
        
    	books = Arrays.asList(new Book(30, "XXX"), new Book(15, "ZZZ"));
    	Writer w2 = new Writer("Sohan", books);    	
        
    	List<Writer> writers = Arrays.asList(w1, w2);
    	Book book = writers.stream().flatMap(writer -> writer.getBooks().stream())
    			.max(new BookComparator()).get();
        
    	System.out.println("Name:"+book.getName()+", Price:"+ book.getPrice() );
    }
}  
```

**Writer.java**

```java
public class Writer {
	private String name;
	private List<Book> books;
	public Writer(String name, List<Book> books) {
		this.name = name;
		this.books = books;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public List<Book> getBooks() {
		return books;
	}
	public void setBooks(List<Book> books) {
		this.books = books;
	}
} 

```

**Book.java**

```java
public class Book {
	private int price;
	private String name;
	public Book(int price, String name) {
		this.price = price;
		this.name = name;
	}
	public int getPrice() {
		return price;
	}
	public void setPrice(int price) {
		this.price = price;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
} 

```

**BookComparator.java**

```java
public class BookComparator implements Comparator<Book> {
	@Override
	public int compare(Book b1, Book b2) {
		if (b1.getPrice() > b2.getPrice()) {
			return 1;
		} else if (b1.getPrice() == b2.getPrice()) {
			return 0;
		} else {
			return -1;
		}
	}
} 
```

#### 基础类型 Stream

上一节提到了三个Stream中最常用的三个无状态方法，在 Stream 的无状态方法中还有几个和map()与flatMap()对应的方法，它们分别是：

1. `mapToInt`
2. `mapToLong`
3. `mapToDouble`
4. `flatMapToInt`
5. `flatMapToLong`
6. `flatMapToDouble`

这六个方法首先从方法名中就可以看出来，它们只是在map()或者flatMap()的基础上对返回值进行转换操作，按理说没必要单拎出来做成一个方法，实际上它们的关键在于返回值：

1. mapToInt返回值为**IntStream**
2. mapToLong返回值为**LongStream**
3. mapToDouble返回值为**DoubleStream**
4. flatMapToInt返回值为**IntStream**
5. flatMapToLong返回值为**LongStream**
6. flatMapToDouble返回值为**DoubleStream**

在JDK5中为了使Java更加的面向对象，引入了包装类的概念，八大基础数据类型都对应着一个包装类，这使你在使用基础类型时可以无感的进行自动拆箱/装箱，也就是自动使用包装类的转换方法。

比如，在最前文的示例中，我用了这样一个例子：

```java
Stream<Integer> integerStream = Stream.of(1, 2, 3);
```

**我在创建Stream中使用了基本数据类型参数，其泛型则被自动包装成了 Integer**，但是我们有时可能忽略自动拆装箱也是有代价的，如果我们想在使用Stream中忽略这个代价则可以使用 Stream 中转为基础数据类型设计的 Stream：

1. IntStream：对应 基础数据类型中的 int、short、char、boolean
2. LongStream：对应基础数据类型中的long
3. DoubleStream：对应基础数据类型中的double和float

在这些接口中都可以和上文的例子一样通过 of 方法构造 Stream，且不会自动拆装箱。

**所以上文中提到的那六个方法实际上就是将普通流转换成这种基础类型流**，在我们需要的时候可以拥有更高的效率。

基础类型流在API方面拥有Stream一样的API，所以在使用方面只要明白了Stream，基础类型流也都是一样的。

**注** ：IntStream、LongStream和DoubleStream都是接口，但并非继承自Stream接口。

#### 无状态方法的循环合并

说完无状态的这几个方法我们来看一个前文中的例子：

```java
List<Integer> list = List.of(1, 2, 3).stream()
        .filter(i -> i > 2)
        .filter(i -> i < 10)
        .filter(i -> i % 2 == 0)
        .collect(toList());
```

在这个例子中我用了三次filter方法，那么大家觉得Stream会循环三次进行过滤吗？

如果换掉其中一个filter为map，大家觉得会循环几次？

```java
List<Integer> list = List.of(1, 2, 3).stream()
        .map(i -> i * 10)
        .filter(i -> i < 10)
        .filter(i -> i % 2 == 0)
        .collect(toList());
```

从我们的直觉来看，需要先使用map方法对所有元素做处理，然后再使用filter方法做过滤，所以需要执行三次循环。

但回顾无状态方法的定义（此方法的执行无需依赖前面方法执行的结果集！！！！），你可以发现其他这三个条件可以放在一个循环里面做，**因为filter 只依赖 map 的计算结果，而不必依赖 map 执行完后的结果集，所以只要保证先操作 map 再操作 filter，它们就可以在一次循环内完成，这种优化方式被称为`循环合并`**。

**所有的无状态方法都可以放在同一个循环内执行，它们也可以方便的使用并行流在多个 CPU 上执行。**

### 有状态 API

前面说完了无状态方法，有状态方法就比较简单了，只看名字就可以知道它的作用：

| 方法名                         | 方法结果                                                     |
| ------------------------------ | ------------------------------------------------------------ |
| distinct()                     | 元素去重。                                                   |
| sorted()                       | 元素排序，重载的两个方法，需要的时候可以传入一个排序对象。   |
| limit(long maxSize)            | 传入一个数字，代表只取前X个元素。                            |
| skip(long n)                   | 传入一个数字，代表跳过X个元素，取后面的元素。                |
| takeWhile(Predicate predicate) | JDK9 新增，传入一个断言参数当第一次断言为false时停止，返回前面断言为true的元素。 |
| dropWhile(Predicate predicate) | JDK9新增，传入一个断言参数当第一次断言为false时停止，删除前面断言为true的元素。 |

**以上就是所有的有状态方法，它们的方法执行都必须依赖前面方法执行的结果集才能执行，比如排序方法就需要依赖前面方法的结果集才能进行排序**。

同时`limit`方法和`takeWhile`是两个短路操作方法，这意味效率更高，因为可能内部循环还没有走完时就已经选出了我们想要的元素。

**所以有状态的方法不像无状态方法那样可以在一个循环内执行，<u>每个有状态方法都要经历一个单独的内部循环</u>，所以编写代码时的顺序会影响到程序的执行结果以及性能，希望各位读者在开发过程中注意**。

## Stream 终结流 API

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/image-20221005172000644.png)

### 简单聚合 API

Stream的聚合方法比上一篇讲过的无状态和有状态方法都要多，但是其中也有一些是喵一眼就能学会的，第一节我们先来说说这部分方法：

- `count()`：返回 Stream 中元素的size大小。

- `forEach()`：通过内部循环 Stream 中的所有元素，对每一个元素进行消费，此方法没有返回值。

  ```java
  List<Integer> list = Arrays.asList(1, 2, 3);
  // list.stream().map(i -> i * 10).forEach(i -> System.out.println(i));
  list.stream().map(i -> i * 10).forEach(System.out::println);
  ```

- `forEachOrder()`：和上面方法的效果一样，但是这个可以**保持消费顺序**，哪怕是在多线程环境下。

- `anyMatch(Predicate predicate)`：这是一个短路操作，通过传入断言参数判断是否有元素能够匹配上断言。

  ```java
  List<Integer> list = Arrays.asList(1, 2, 3);
  System.out.println(list.stream().map(i -> i * 10).anyMatch(i -> i >= 20));
  ```

- `allMatch(Predicate predicate)`：这是一个短路操作，通过传入断言参数返回是否所有元素都能匹配上断言。

- `noneMatch(Predicate predicate)`：这是一个短路操作，通过传入断言参数判断是否所有元素都无法匹配上断言，如果是则返回true，反之则false。

- `findFirst()`：这是一个短路操作，返回Stream中的第一个元素，Stream可能为空所以返回值用Optional处理。

- `findAny()`：这是一个短路操作，返回Stream中的任意一个元素，串型流中一般是第一个元素，Stream可能为空所以返回值用Optional处理。

虽然以上都比较简单，但是这里面有五个涉及到短路操作的方法我还是想提两嘴：

首先是`findFirst()`和`findAny()`这两个方法， 由于它们只需要拿到一个元素就能方法就能结束，所以短路效果很好理解。

接着是`anyMatch`方法，它只需要匹配到一个元素方法也能结束，所以它的短路效果也很好理解。

最后是`allMatch`方法和`noneMatch`，乍一看这两个方法都是需要遍历整个流中的所有元素的，其实不然，比如allMatch只要有一个元素不匹配断言它就可以返回false了，noneMatch只要有一个元素匹配上断言它也可以返回false了，所以它们都是具有短路效果的方法。

### 规约 API

#### reduce：反复求值

我们来说说归约，由于这个词过于抽象，我不得不找了一句通俗易懂的解释来翻译这句话，下面是归约的定义：

> 将一个Stream中的所有元素反复结合起来，得到一个结果，这样的操作被称为归约。

**注：在函数式编程中，这叫做折叠( fold )。**

**举个很简单的例子，我有 1、2、3 三个元素，我把它们俩俩相加（1 + 2 + 3 = 6），最后得出 6 这个数字，这个过程就是归约**。

再比如，我有1、2、3三个元素，我把它们俩俩比较，最后挑出最大的数字3或者挑出最小的数字1，这个过程也是归约。

下面我举一个求和的例子来演示归约，使用 reduce 方法：

```java
Optional<Integer> reduce = List.of(1, 2, 3).stream()
        .reduce((i1, i2) -> i1 + i2);
```

首先你可能注意到了，我在上文的小例子中一直在用俩俩这个词，**这代表归约是俩俩的元素进行处理然后得到一个最终值，所以reduce的方法的参数是一个二元表达式**，它将两个参数进行任意处理，最后得到一个结果，其中它的参数和结果必须是同一类型。

比如代码中的，i1 和 i2 就是二元表达式的两个参数，它们分别代表元素中的第一个元素和第二个元素，当第一次相加完成后，所得的结果会赋值到i1身上，i2则会继续代表下一个元素，直至元素耗尽，得到最终结果。

如果你觉得这么写不够优雅，也可以使用Integer中的默认方法：

```java
Optional<Integer> reduce = List.of(1, 2, 3).stream()
                .reduce(Integer::sum);
```

这也是一个以`方法引用`代表lambda表达式的例子。

你可能还注意到了，它们的返回值是 Optional 的，这是预防 Stream 没有元素的情况。

你也可以想办法去掉这种情况，那就是让元素中至少要有一个值，这里reduce提供一个重载方法给我们：

```java
Integer reduce = List.of(1, 2, 3).stream()
                .reduce(0, (i1, i2) -> i1 + i2);
```

如上例，在二元表达式前面多加了一个参数，这个参数被称为初始值，这样哪怕你的Stream没有元素它最终也会返回一个0，这样就不需要Optional了。

在实际方法运行中，初始值会在第一次执行中占据 i1 的位置，i2 则代表Stream中的第一个元素，然后所得的和再次占据i1的位置，i2代表下一个元素。

> 不过使用初始值不是没有成本的，它应该符合一个原则：`accumulator.apply(identity, i1) == i1`，也就是说在第一次执行的时候，它的返回结果都应该是你 Stream 中的第一个元素。
>
> 比如我上面的例子是一个相加操作，则第一次相加时就是`0 + 1 = 1`，符合上面的原则，作此原则是为了保证并行流情况下能够得到正确的结果。
>
> 如果你的初始值是1，则在并发情况下每个线程的初始化都是1，那么你的最终和就会比你预想的结果要大。

#### max：利用归约求最大

max方法也是一个归约方法，它是直接调用了reduce方法。

先来看一个示例：

```java
List<Integer> list = Arrays.asList(1, 2, 3);
Optional<Integer> max = list.stream().map(i -> i * 10).max((o1, o2) -> o1 - o2);
```

没错，这就是max方法用法，这让我觉得我不是在使用函数式接口，当然你也可以使用Integer的方法进行简化：

```java
Optional<Integer> max = list.stream().map(i -> i * 10).max(Integer::compare);
```

哪怕如此，这个方法依旧让我感觉到很繁琐，我虽然可以理解在max方法里面传参数是为了让我们自己自定义排序规则，但我不理解为什么没有一个默认按照自然排序进行排序的方法，而是非要让我传参数。

直到后来我想到了基础类型Stream，果然，它们里面是可以无需传参直接拿到最大值：

```java
OptionalLong max = LongStream.of(1, 2, 3).max();
```

果然，我能想到的，类库设计者都想到了～

**注** ：OptionalLong 是 Optional 对基础类型 long 的封装。

#### min：利用归约求最小

min还是直接看例子吧：

```java
Optional<Integer> max = List.of(1, 2, 3).stream()
                .min(Integer::compare);
```

它和max区别就是底层把 `>` 换成了 `<`，过于简单，不再赘述。

### 收集器 API：collect

收集器 `collect`，它的作用是对Stream中的元素进行收集而形成一个新的集合。

```java
<R, A> R collect(Collector<? super T, A, R> collector);
```

收集器是用来收集Stream的元素的，最后收集成什么我们可以自定义，但是我们一般不需要自己写，因为JDK内置了一个Collector的实现类——静态工厂 `Collectors`。

在这个静态工厂类中，几乎满足了我们日常中所有的操作；所以说，我们只看下，这个静态工厂类中，有哪些实现就行了

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53405db7bd424fd6a54e14c76f0658e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 收集方法

通过Collectors我们可以利用它的内置方法很方便的进行数据收集：

比如你想把元素收集成集合，那么你可以使用toCollection或者toList方法，不过我们一般不使用toCollection，因为它需要传参数，没人喜欢传参数。

你也可以使用toUnmodifiableList，它和toList区别就是它返回的集合不可以改变元素，比如删除或者新增。

再比如你要把元素去重之后收集起来，那么你可以使用toSet或者toUnmodifiableSet。

接下来放一个比较简单的例子：

```java
// toList
List.of(1, 2, 3).stream().collect(Collectors.toList());

// toUnmodifiableList
List.of(1, 2, 3).stream().collect(Collectors.toUnmodifiableList());

// toSet
List.of(1, 2, 3).stream().collect(Collectors.toSet());

// toUnmodifiableSet
List.of(1, 2, 3).stream().collect(Collectors.toUnmodifiableSet());
```

以上这些方法都没有参数，拿来即用，toList底层也是经典的ArrayList，toSet 底层则是经典的HashSet。

也许有时候你也许想要一个收集成一个Map，比如通过将订单数据转成一个 Map 结构（key:订单号, value:订单实体)，那么你可以使用 `toMap()`：

```java
List<Order> orders = List.of(new Order(), new Order());

Map<String, Order> map = orders.stream()
        .collect(Collectors.toMap(Order::getOrderNo, order -> order));
```

toMap() 具有两个参数：

1. 第一个参数代表key，它表示你要设置一个Map的key，我这里指定的是元素中的orderNo。
2. 第二个参数代表value，它表示你要设置一个Map的value，我这里直接把元素本身当作值，所以结果是一个Map<String, Order>。

你也可以将元素的属性当作值：

```java
List<Order> orders = List.of(new Order(), new Order());

Map<String, List<Item>> map = orders.stream()
        .collect(Collectors.toMap(Order::getOrderNo, Order::getItemList));
```

这样返回的就是一个订单号+商品列表的Map了。

toMap() 还有两个伴生方法：

- toUnmodifiableMap()：返回一个不可修改的Map。
- toConcurrentMap()：返回一个线程安全的Map。

这两个方法和toMap() 的参数一模一样，唯一不同的就是底层生成的Map特性不太一样，我们一般使用简简单单的toMap() 就够了，它的底层是我们最常用的HashMap() 实现。

**toMap() 功能虽然强大也很常用，但是它却有一个致命缺点。**

**我们知道HahsMap遇到相同的key会进行覆盖操作，但是toMap() 方法生成Map时如果你指定的key出现了重复，那么它会直接抛出异常。**

比如上面的订单例子中，我们假设两个订单的订单号一样，但是你又将订单号指定了为 key，那么该方法会直接抛出一个IllegalStateException，因为它不允许元素中的key是相同的。

#### 分组方法

如果你想对数据进行分类，但是你指定的key是可以重复的，那么你应该使用groupingBy 而不是toMap。

举个简单的例子，我想对一个订单集合以订单类型进行分组，那么可以这样：

```java
List<Order> orders = List.of(new Order(), new Order());

Map<Integer, List<Order>> collect = orders.stream()
        .collect(Collectors.groupingBy(Order::getOrderType));
```

直接指定用于分组的元素属性，它就会自动按照此属性进行分组，并将分组的结果收集为一个List。

```java
List<Order> orders = List.of(new Order(), new Order());

Map<Integer, Set<Order>> collect = orders.stream()
        .collect(Collectors.groupingBy(Order::getOrderType, toSet()));
```

groupingBy还提供了一个重载，让你可以自定义收集器类型，所以它的第二个参数是一个Collector收集器对象。

对于Collector类型，我们一般还是使用Collectors类，这里由于我们前面已经使用了Collectors，所以这里不必声明直接传入一个toSet()方法，代表我们将分组后的元素收集为Set。

groupingBy还有一个相似的方法叫做groupingByConcurrent()，这个方法可以在并行时提高分组效率，但是它是不保证顺序的，这里就不展开讲了。

#### 分区方法

接下来我将介绍分组的另一种情况——分区，名字有点绕，但意思很简单：

- 将数据按照TRUE或者FALSE进行分组就叫做分区。

举个例子，我们将一个订单集合按照是否支付进行分组，这就是分区：

```java
List<Order> orders = List.of(new Order(), new Order());

Map<Boolean, List<Order>> collect = orders.stream()
        .collect(Collectors.partitioningBy(Order::getIsPaid));
```

因为订单是否支付只具有两种状态：已支付和未支付，这种分组方式我们就叫做分区。

和groupingBy一样，它还具有一个重载方法，用来自定义收集器类型：

```java
List<Order> orders = List.of(new Order(), new Order());

Map<Boolean, Set<Order>> collect = orders.stream()
        .collect(Collectors.partitioningBy(Order::getIsPaid, toSet()));
```

#### 经典复刻方法

终于来到最后一节了，请原谅我给这部分的方法起了一个这么土的名字，但是这些方法确实如我所说：经典复刻。

换言之，就是Collectors把Stream原先的方法又实现了一遍，包括：

1. **map**  → `mapping`
2. **filter**  → `filtering`
3. **flatMap**  → `flatMapping`
4. **count**  → `counting`
5. **reduce**  → `reducing`
6. **max**  → `maxBy`
7. **min ** → `minBy`

这些方法的功能我就不一一列举了，之前的文章已经讲的很详尽了，唯一的不同是某些方法多了一个参数，这个参数就是我们在分组和分区里面讲过的收集参数，你可以指定收集到什么容器内。

我把它们抽出来主要想说的为什么要复刻这么多方法处理，这里我说说个人见解，不代表官方意见。

**我觉得主要是为了功能的组合。**

什么意思呢？比方说我又有一个需求：使用订单类型对订单进行分组，并找出每组有多少个订单。

订单分组我们已经讲过了，找到其每组有多少订单只要拿到对应list的size就行了，但是我们可以不这么麻烦，而是一步到位，在输出结果的时候键值对就是订单类型和订单数量：

```java
Map<Integer, Long> collect = orders.stream()
        .collect(Collectors.groupingBy(Order::getOrderType, counting()));
```

就这样，就这么简单，就好了，这里等于说我们对分组后的数据又进行了一次计数操作。

上面的这个例子可能不对明显，当我们需要对最后收集之后的数据在进行操作时，一般我们需要重新将其转换成Stream然后操作，但是使用Collectors的这些方法就可以让你很方便的在Collectors中进行数据的处理。

再举个例子，还是通过订单类型对订单进行分组，**并拿到每种类型订单金额最大的那个**，那么我们就可以这样：

```java
List<Order> orders = List.of(new Order(), new Order());        

Map<Integer, Optional<Order>> collect2 = orders.stream()
        .collect(groupingBy(Order::getOrderType, maxBy(Comparator.comparing(Order::getMoney))));
```

更简洁，也更方便，不需要我们分组完之后再去一一寻找最大值了，可以一步到位。

再来一个分组之后，求各组订单金额之和的：

```java
List<Order> orders = List.of(new Order(), new Order());        

Map<Integer, Long> collect = orders.stream()
        .collect(groupingBy(Order::getOrderType, summingLong(Order::getMoney)));
```

不过summingLong这里我们没有讲，它就是一个内置的请和操作，支持Integer、Long和Double。

还有一个类似的方法叫做averagingLong看名字就知道，求平均的，都比较简单，建议大家没事的时候可以扫两眼。

#### 其他

该结束了，最后一个方法joining()，用来拼接字符串很实用：

```java
List<Order> orders = List.of(new Order(), new Order());

String collect = orders.stream()
        .map(Order::getOrderNo).collect(Collectors.joining("，"));
```

这个方法的方法名看着有点眼熟，没错，String类在JDK8之后新加了一个`join()` 方法，也是用来拼接字符串的，Collectors的joining不过和它功能一样，底层实现也一样，都用了 StringJoiner 类。

### toArray

顾名思义就是将 Stream 转换成数组

```java
Object[] obarray = Stream.of("aa","bb","cc").toArray();
 
int[] array = IntStream.of(12, 4, 4, 6, 10, 3, 6, 8, 9).toArray();

int[] nums = Arrays.asList(1, 2, 3).stream().mapToInt(Integer::intValue).toArray();
```
